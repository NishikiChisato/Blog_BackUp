---
title: 单链表即双链表的数组实现
tags: [链表]
categories: OI
---

## 单链表

单链表的数组实现需要一个数组 `e[N]` 用来存储每个节点的值，`ne[N]` 用来存储当前节点的下一个节点的位置，`idx` 用来表示当前所用的节点数，`head` 表示头指针，指向的是**头节点**

由于是数组实现，因此每个节点都会对应一个数组下标，**我们并不能通过数组下标来确定该节点处于链表中的位置**，这是因为后面的节点完全可以「插入」到前面的节点当中，因此数组下标所表示的仅仅是「该节点是第几次插入的节点，当然这里需要加一」

详细定义如下：

```cpp
const int N = 1e5 + 10;

int head, e[N], ne[N], idx;
//初始化函数
void init()
{
    head = -1;//-1表示指空
    idx = 0;//初始时已用节点数为0，数组下标从0开始存储
}

// 头插，在头节点前面插入
void add_head(int x)
{
    e[idx] = x;
    ne[idx] = head;
    head = idx;
    idx++;
}

//在第下标为k的数后面插入一个数
//下标为k对应的是第k+1次操作
void insert(int k, int x)
{
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx++;
}

//删除下标为k的数后面那个数
//由于题目保证所有操作均有效，因此不会删除一个不存在的节点
void remove(int k)
{
    ne[k] = ne[ne[k]];
}
```

​	 

## 双链表

在双链表的定义部分，我们可以偷一下懒，不像单链表定义 `head` 那样去定义头指针和尾指针，我们直接让**下标为 0 的节点作为头节点**，**下标为 1 的节点作为尾节点**

在数据结构的设计部分，我们需要一个数组 `e[N]` 来存储每个节点的数值，数组 `l[N]` 和 `r[N]` 来表示当前节点的前一个节点**下标**和后一个节点**下标**，`idx` 表示当前已经用到的节点数量

下面我们直接给出其定义

```cpp
const int N = 1e5 + 10;

int e[N], l[N], r[N], idx;

//下标为0和1的点分别作为头节点和尾节点
//由于占用了两个节点，因此idx直接从2开始，表示已经使用了2个节点
void init()
{
    r[0] = 1;
    l[1] = 0;
    idx = 2;
}

//删除下标为k的节点
void remove(int k)
{
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

//在下标为k的节点后面插入一个节点
//默认是在右边插入，如果需要在左边插入的话可以写insert(l[k], x)
//由于有两个默认节点的存在，因此第1次插入节点的对应下标为2，即第k次插入的节点在数组当中存储在k+1的下标处
void insert(int k, int x)
{
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    l[r[k]] = idx;
    r[k] = idx;
    idx++;
}
```

双链表在做题的时候要注意一点：第 $k$ 次插入的节点所对应的下标为 $k+1$ （第1次插入对应的是2）

而在单链表中，第 $k$ 次插入的节点对应的下标为 $k-1$ （第1次插入对应的是0）