---
title: CSAPP 第三章 程序的机器级表示
tags: CSAPP
categories: CSAPP
---

## 数据格式

我们采取 Intel 的标准，字（word）用来表示 16 位数据类型，因此 32 位也被称为 双字（double word），64 位被称为 四字（quad word）

|C声明|Intel 数据类型 |汇编代码后缀 | 大小（字节）|
|:---:|:--:|:--:|:--:|
|char|字节|b|1|
|short|字|w|2|
|int|双字|l|4|
|long|四字|q|8|
|char*|四字|q|8|
|float|单精度|s|4|
|double|双精度|l|8|

汇编指令都会有一个字符后缀，用来表示数据的大小。例如：movb（传送字节）、movw（传送字）、movl（传送双字）、movq（传送四字）

后缀 l 用来表示双字，这是因为 32 位数也被看成 长字（long word）

我们观察上表可以得出，后缀 l 同时表示了双字和双精度，但这并不会起冲突，因为浮点数的运算是一套完全不同的指令和寄存器

这里我们可以看出，所有的操作数都以一个统一的格式给出，每一种类型都对应一个后缀，这一点也为后续的数据传送提供了便利



## 访问信息

一个 x86-64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的通用目的寄存器，这些寄存器用来存储整数数据和指针

下表给出了所有寄存器，名称从左到右依次为 64 位、32 位、 16 位、 8 位

| 寄存器名称 | 作用 | 寄存器名称 | 作用 |
| :----: | :----: | :----: | :----: |
| %rax  %eax  $ax  %al | 保存返回值 | %rbx  %ebx  %bx  %bl | 被调用者保存 |
| %rcx  %ecx  %cx  %cl | 第 4 个参数 | %rdx  %edx  %dx  %dl | 第 3 个参数 |
| %rsi  %esi  %si  %sil | 第 2 个参数 | %rdi  %edi  %di  %dil | 第 1 个参数 |
| %rbp  %ebp  %bp  %bpl | 被调用者保存 | %rsp  %esp  %sp  %spl | 栈指针 |
| %r8  %r8d  %r8w  %r8b | 第 5 个参数 | %r9  %r9d  %r9w  %r9b | 第 6 个参数 |
| %r10  %r10d  %r10w  %r10b | 调用者保存 | %r11  %r11d  %r11w  %r11b | 调用者保存 |
| %r12  %r12d  %r12w  %r12b | 被调用者保存 | %r13  %r13d  %r13w  %r13b | 被调用者保存 |
| %r14  %r14d  %r14w  %r14b | 被调用者保存 | %r15  %r15d  %r15w  %r15b | 被调用者保存 |

我们详细解释一下这些寄存器的作用

保存返回值是指，用于保存函数调用时的返回值

栈指针是指栈顶指针

第 $i$ 个参数是指，在函数调用时，需要传递函数参数，当函数参数小于 6 时由寄存器保存，大于 6 个的部分由栈帧保存

调用者保存以及被调用者保存的意思是，这个寄存器的值可以被调用者或者被调用者修改，但又必须保证该寄存器的值不变，因此需要调用者或者被调用者保存在自己的栈帧内

出于向前兼容的特性，当我们向这些寄存器当中写入小于 8 字节的值，剩下的字节变化按照下面两条规则来：

生成 1 字节和 2 字节的指令，会保证剩下的字节不变

生成 4 字节的指令会将高位 4 字节全部置零

### 操作数指示符

大多数指令有一个或者多个操作数，操作数是指一个操作当中需要使用的**源数据值**和放置结果的**目的地址**

源数据值可以以常数的形式给出，也可以通过访问寄存器或内存来读取。目的地址可以是寄存器也可以是内存。因此，操作数可以被划分为三种类型：

* 立即数（immediate），用来**直接给出常数值**。立即数的书写是在 $ 后面跟一个 C 语言的整数
* 寄存器，通过访问某个寄存器得到其内容，当然是允许间接访问的。我们将寄存器集合看成一个数组 $R$ ，用寄存器标识符作为数组索引。即用 $r_a$ 来表示任意寄存器 $a$ ，用 $R[r_a]$ 来表示该寄存器的值
* 内存引用，会根据计算出来的地址来访问某个特定的内存，也允许间接访问。我们将内存看成一个很大的字节数组，我们用 $M_b[Addr]$ 来表示存储在内存中从 $Addr$ 地址处的 $b$ 个字节的内存引用。为了描述方便，我们通常会省略下标 $b$ 

关于内存寻址，这里我们给出最一般的情况，即：$Imm(r_b,r_i,s)$ 用来表示 $M[Imm+R[r_b]+R[r_i]\cdot s]$ ，其中 $Imm$ 为立即数偏移，$r_b$ 为基址寄存器，$r_i$ 为变址寄存器，$s$ 为比例因子，其值只能是1、2、4、8

​	 

### 数据传送指令

该指令会将数据从一个位置**复制**到另一个位置

下面我们给出数据传送指令—— $MOV$ 类，它们会将数据从源位置**复制**到目标位置而不做任何变化

$MOV$ 类指令由四条基本指令构成，它们之间的区别在于操作的数据大小不同

当然，源操作数的大小可以不按照传送指令标识出的大小，比如我可以用 movq 来传送双字，只不过这样会将高位的 2 个字节传送而已。不过这四条不建议这么使用，因为对于这种源小于目的的情况，会有专门的传送指令来实现

|     指令     |     效果     |      描述      |
| :----------: | :----------: | :------------: |
| $MOV\ S,\ D$ | $D\ \gets S$ |      传送      |
|     movb     |              |    传送字节    |
|     movw     |              |     传送字     |
|     movl     |              |    传送双字    |
|     movq     |              |    传送四字    |
|   movabsq    |              | 传送绝对的四字 |

源操作数的值可以是一个立即数、存储在寄存器或内存当中的值。目的操作数指定一个位置，要么是寄存器，要么是内存地址。并且传送指令的两个操作数不能都指向内存地址

对于常规的四条 $MOV$ 指令，它们是以补码的形式看到源数据，如果传送的数据大小大于源数据，它们会将源数据传送到目的地，并**将高位按照补码的规则补充**。而 movabsq 是以无符号来传输四字的，并且是以 64 位立即数来作为源操作数，以寄存器作为目的

对于源小于目的的情况，可以使用 $MOVZ$ 和 $MOVS$ 来实现。对于前者，它会将剩余字节全部填充 0 ，对于后者，它会将剩余字节按符号进行填充，即对源操作数的最高位进行复制

|     指令      |         效果         |           描述           |
| :-----------: | :------------------: | :----------------------: |
| $MOVZ\ S,\ R$ | $R\ \gets (零拓展)S$ |     以零拓展进行传送     |
|    movzbw     |                      | 前一个为源，后一个为目的 |
|    movzbl     |                      |                          |
|    movzwl     |                      |                          |
|    movzbq     |                      |                          |
|    movzwq     |                      |                          |

$MOVZ$ 指令只能以寄存器或内存地址作为源，以寄存器作为目的

|     指令      |              效果              |          描述           |
| :-----------: | :----------------------------: | :---------------------: |
| $MOVS\ S,\ R$ |     $R\ \gets (符号拓展)S$     |   传送符号拓展的字节    |
|    movsbw     |                                |                         |
|    movsbl     |                                |                         |
|    movswl     |                                |                         |
|    movsbq     |                                |                         |
|    movswq     |                                |                         |
|    movslq     |                                |                         |
|     cltq      | $\%rax\ \gets (符号拓展)\%eax$ | 把 %eax 符号拓展到 %rax |

$MOVS$ 类指令只能以寄存器或内存地址作为源，以寄存器作为目的。cltq 指令只能作用于寄存器 %eax 和 %rax

​	 

### 压入和弹出栈数据

程序栈存放在内存当中的某个区域，**栈向下增长**，栈顶元素的地址是所有栈中元素地址中最低的，栈指针 %rsp 保存着栈顶元素的地址

下面两条指令可以将数据压入程序栈在以及从程序栈中弹出数据

|    指令    |                       效果                        |                    描述                     |
| :--------: | :-----------------------------------------------: | :-----------------------------------------: |
| $pushq\ S$ | $R[\%rsp]\gets R[\%rsp]-8\ ;\ M[R[\%rsp]]\gets S$ |   先将栈顶指针下移，再将四字 $S$ 压入栈中   |
|  $pop\ D$  | $D\gets M[R[\%rsp]]\ ;\ R[\%rsp]\gets R[\%rsp]+8$ | 先将栈顶元素弹出到 $D$ 中，再将栈顶指针上移 |

​	 

## 算术和逻辑操作

下面我们给出对于整数的算术和逻辑操作，当然这些指令大多有操作数大小的变种（除了 leaq 没有）。就比如，ADD 指令可以分为 addb、addw、addl、addq 等

|     指令      |          效果          |        描述        |
| :-----------: | :--------------------: | :----------------: |
| $leaq\ S,\ D$ |    $D\ \gets\ \&S$     |    加载有效地址    |
|   $INC\ D$    |    $D\ \gets\ D+1$     |        加 1        |
|   $DEC\ D$    |    $D\ \gets\ D-1$     |        减 1        |
|   $NEG\ D$    |     $D\ \gets\ -D$     |        取负        |
|   $NOR\ D$    |   $D\ \gets\ \sim D$   |        取补        |
| $ADD\ S,\ D$  |    $D\ \gets\ D+S$     |         加         |
| $SUB\ S,\ D$  |    $D\ \gets\ D-S$     |         减         |
| $IMUL\ S,\ D$ | $D\ \gets\ D\times S$  |         乘         |
| $XOR\ S,\ D$  | $D\ \gets\ D \oplus S$ |        异或        |
|  $OR\ S,\ D$  |  $D\ \gets\ D\ |\ S$   |         或         |
| $AND\ S,\ D$  |  $D\ \gets\ D\ \&\ S$  |         与         |
| $SAL\ k,\ D$  |    $D\ \gets\ D<<k$    |        左移        |
| $SHL\ k,\ D$  |    $D\ \gets\ D<<k$    | 左移，等同于 $SAL$ |
| $SAR\ k,\ D$  |  $D\ \gets\ D>>_{A}k$  |      算术右移      |
| $SHR\ k,\ D$  |  $D\ \gets\ D>>_{L}k$  |      逻辑右移      |

加载有效地址（load effective address）指令 leaq ，可以从内存当中读取数据到寄存器当中。但实际上它并不会引用内存（也就是读取内存当中某个值的意思），它只会将该内存的**地址**赋值给寄存器，因此我们用 C 语言的地址引用操作符来描述这个过程

举个例子，如果寄存器 $\%rdx$ 的值为 $x$ （这里的 $x$ 是内存当中的某个地址，是间接寻址），那么 $leaq 7(\%rdx, \%rdx, 4) \%rax$ 表示，将寄存器 $\%rax$ 的值设置成 $5x$ ，这里的 $5x$ 是一个内存地址，也就是我需要通过 $M[5x]$ 才能找到我需要的值

​	 

### 特殊的算术操作

将两个 64 位有符号或无符号整数相乘的乘积会得到一个 128 位（16字节）的结果。x86-64指令集对 128 位也提供相应的支持，16 字节称为八字（oct word）

|    指令    |                             效果                             |    描述    |
| :--------: | :----------------------------------------------------------: | :--------: |
| $imulq\ S$ |       $R[\%rdx]:R[\&rax]\ \gets\ S\ \times\ R[\%rax]$        | 有符号乘法 |
| $mulq\ S$  |       $R[\%rdx]:R[\&rax]\ \gets\ S\ \times\ R[\%rax]$        | 无符号乘法 |
|   $cqto$   |        $R[\%rdx]:R[\%rax]\ \gets\ (符合拓展)R[\%rax]$        | 四字转八字 |
| $idivq\ S$ | $R[\%rdx]\ \gets\ R[\%rdx]:R[\%rax]\ \bmod\ S \\ R[\%rax]\ \gets\ R[\%rdx]:R[\%rax]\ /\ S$ | 有符号除法 |
| $divq\ S$  | $R[\%rdx]\ \gets\ R[\%rdx]:R[\%rax]\ \bmod\ S \\ R[\%rax]\ \gets\ R[\%rdx]:R[\%rax]\ /\ S$ | 无符号除法 |

我们看到，一个寄存器是存储 64 位的，存储 128 位需要两个寄存器。由于采取的是小端存储，因此寄存器 $\%rdx$ 存储的是**数字**低 8 位，寄存器 $\%rax$ 存储的是**数字**高 8 位

这里我们说的是数字的字节位，不是底层的二进制的字节位，二进制的字节位是 $\%rdx$ 为高 8 位， $\%rax$ 为低 8 位

​	 

## 控制

我们写程序的时候，通常会有判断、循环和分支，也就是说，我们的程序的执行不可能是一条一条往下的，一定会有跳跃。程序跳过了某些语句，这里就会涉及到程序的控制

机器代码提供两种基本的机制来实现复杂的控制行为：测试数据值，再根据结果来改变控制流或数据流

​	 

### 条件码

上面我们看到，CPU **内部**维护这 16 个整数寄存器，但如果仅仅维护这些寄存器的话，是无法实现控制操作的。因此 CPU 内部还维护者一组**单个位**的条件码寄存器，它们用来描述最近的算术和逻辑操作的属性，可以通过检测这些寄存器来实现条件控制

条件码有：

* `CF` ：进位标志，**最近**的操作使最高位产生了进位。当然也可以用于检查无符号操作的溢出
* `ZF` ：零标志，**最近**的操作得出的结果为 0 
* `SF` ：符号标志，最近的操作得到的结果为负数
* `OF` ：溢出标志，最近的操作导致一个补码溢出，正溢出或负溢出

我们执行前面的指令时，会对这些条件码进行不断的更新（当然，也会不断更新前面的整数寄存器），然后我们便可以通过检查这些标志位来实现控制跳转

我们还有两类指令是**只会改变条件码而不会改变整数寄存器**，它们如下：

|       指令        |    基于    |                             描述                             |
| :---------------: | :--------: | :----------------------------------------------------------: |
| $CMP\ S_1,\ S_2$  | $S_2-S_1$  |                    比较，用于比较二者大小                    |
|      $cmpb$       |            |                           比较字节                           |
|      $cmpw$       |            |                            比较字                            |
|      $cmpl$       |            |                           比较双字                           |
|      $cmpq$       |            |                           比较四字                           |
| $TEST\ S_1,\ S_2$ | $S_1\&S_2$ | 同 $AND$ ，$S_1$ 与 $S_2$ 一般一样，用于检查是正数、零还是负数 |
|      $testb$      |            |                           测试字节                           |
|      $testw$      |            |                            测试字                            |
|      $testl$      |            |                           测试双字                           |
|      $testq$      |            |                           测试四字                           |

​	 

### 访问条件码

条件码一般不会直接读取（这么做没有意义），常用的方法有三种：

1. 根据条件码的某种组合，将一个**字节**设置成 0 或者 1
2. 根据条件跳转到程序的某个其他部分
3. 可以有条件的传送数据

后面将会详细介绍这三种条件码使用的情况

#### 设置字节

$SET$ 指令可以根据条件码的组合，进而将某个**字节**设置成 0 或者 1 ，指令的不同后缀表示的是不同的条件而不是操作数的大小

一条 $SET$ 指令的目的操作数是**低位单字节寄存器元素**，**或者是某个单字节的内存地址**，指令会单独对该字节的值进行单独设置（这是设置一个字节的值，不是一个位的值）

|    指令    | 同义名（名字相同而已） |                             效果                             |         设置条件         |
| :--------: | :--------------------: | :----------------------------------------------------------: | :----------------------: |
| $sete\ D$  |         $setz$         |                         $D\gets ZF$                          |         相等、零         |
| $setne\ D$ |        $setnz$         |                 $D\gets\ \textasciitilde ZF$                 |        不等、非零        |
| $sets\ D$  |                        |                         $D\gets SF$                          |           负数           |
| $setns\ D$ |                        |                $D\gets\  \textasciitilde SF$                 |          非负数          |
| $setg\ D$  |        $setnle$        | $D\gets \textasciitilde (SF \bigoplus OF)\& \textasciitilde ZF$ |    大于（有符号 > ）     |
| $setge\ D$ |        $setnl$         |          $D\gets \textasciitilde (SF \bigoplus OF)$          |  大于等于（有符号 >= ）  |
| $setl\ D$  |        $setnge$        |                   $D\gets SF \bigoplus OF$                   |    小于（有符号 < ）     |
| $setle\ D$ |        $setng$         |                $D\gets (SF \bigoplus OF)|ZF$                 |  小于等于（有符号 <= ）  |
| $seta\ D$  |        $setnbe$        |       $D\gets \textasciitilde CF\& \textasciitilde ZF$       |    超过（无符号 > ）     |
| $setae\ D$ |        $setnb$         |                 $D\gets \textasciitilde CF$                  | 超过或相等（无符号 >=）  |
| $setb\ D$  |        $setnae$        |                         $D\gets CF$                          |    低于（无符号 < ）     |
| $setbe\ D$ |        $setna$         |                        $D\gets CF|ZF$                        | 低于或相等（无符号 <= ） |

​	 

#### 跳转指令

下面给出了程序的跳转指令，正常情况下程序是一行一行执行的，出现跳转指令时，程序会跳到一个全新的位置

|      指令       |       同义名       |            跳转条件            |                      描述                      |
| :-------------: | :----------------: | :----------------------------: | :--------------------------------------------: |
|  $jmp\ Lable$   |                    |               无               | 直接跳转（直接跳转到以寄存器的值为地址的地方） |
| $jmp\ *Operand$ |                    |               无               |    间接跳转（以寄存器的值作为地址再次跳转）    |
|   $je\ Lable$   |        $jz$        |              $ZF$              |                    相等、零                    |
|  $jne\ Lable$   |       $jnz$        |      $\textasciitilde ZF$      |                  不相等、非零                  |
|   $js\ Lable$   |                    |              $SF$              |                      负数                      |
|  $jns\ Lable$   |                    |      $\textasciitilde SF$      |                     非负数                     |
|   $jg\ Lable$   | 书中有，不过多赘述 | 这里往下的跳转条件与上面的一致 |                   有符号大于                   |
|  $jge\ Lable$   |                    |                                |                 有符号大于等于                 |
|   $jl\ Lable$   |                    |                                |                   有符号小于                   |
|  $jle\ Lable$   |                    |                                |                 有符号小于等于                 |
|   $ja\ Lable$   |                    |                                |                   无符号超过                   |
|  $jae\ Lable$   |                    |                                |                无符号超过或等于                |
|   $jb\ Lable$   |                    |                                |                   无符号低于                   |
|  $jbe\ Lable$   |                    |                                |                无符号低于或等于                |

​	 

#### 条件传送

条件传送指令有两个操作数，源寄存器或内存地址 $S$ ，和目的寄存器 $D$ 。源值可以从寄存器或内存当中读取，当条件满足时，才会**复制**到目的寄存器中

|      指令       | 同义名 |    传送条件    |       描述       |
| :-------------: | :----: | :------------: | :--------------: |
| $cmove\ S,\ R$  |  看书  | 全部与上面一致 |     相等、零     |
| $cmovne\ S,\ R$ |        |                |   不相等、非零   |
| $cmovs\ S,\ R$  |        |                |       负数       |
| $cmovns\ S,\ R$ |        |                |      非负数      |
| $cmovg\ S,\ R$  |        |                |    有符号大于    |
| $cmovge\ S,\ R$ |        |                |  有符号大于等于  |
| $cmovl\ S,\ R$  |        |                |    有符号小于    |
| $cmovle\ S,\ R$ |        |                |  有符号小于等于  |
| $cmova\ S,\ R$  |        |                |    无符号超过    |
| $cmovae\ S,\ R$ |        |                | 无符号超过或等于 |
| $cmovb\ S,\ R$  |        |                |    无符号低于    |
| $cmovbe\ S,\ R$ |        |                | 无符号低于或等于 |

​	 

### 条件分支

#### 基于条件控制实现的条件分支

我们用一个简单的例子来说明什么叫条件控制来实现条件分支

```cpp
int test(int x, int y)
{
	int result = 0;
	if (x > y)
		result = x - y;
	else
		result = y - x;
	return result;
}
```

这是一个很简单的 `if` 条件判断程序。在通过编译后，会生成其汇编代码，但直接给出汇编代码会造成理解上的困难，所以这里我们给出**等价**的 C 代码，即：

```cpp
int test_goto(int x, int y)
{
	int result = 0;
	bool t = x > y;
	if (!t)
		goto x_g_y;
	result = y - x;
    return result;
x_g_y:
	result = x - y;
	return result;
}
```

显然，我们有如下结论：

对于 C 语言当中的 `if-else` 语句，其通用形式如下：

```cpp
if(test-expr)
    then-statement
else
    else-statement
```

这里的 *test-expr* 是一个整数表达式，其值只有零（解释为假）或非零（解释为真），下面的两条分支语句 *then-statement* 和 *else-statement* **只会执行一个**

对于这种形式，汇编通常会产生如下代码，我们用 C 语言来描述程序控制流

```c++
t = test-expr
if(!t)
    goto false;
	then-statement
    goto done;
false:
	else-statement
done:
```

也就是说，汇编器会为 *then-statement* 和 *else-statement* 生成各自的代码块，但只会执行一个

​	 

#### 基于条件传送来实现条件分支

还是刚刚的例子，我们可以单独算出两条分支的结果，然后再已经条件进行选择，即：

```cpp
int test_goto(int x, int y)
{
	int rval = x - y;
	int eval = y - x;
	int test = x > y;
	if (!test)
		rval = eval;
	return rval;
}
```

为了便于理解这种实现条件分支的方式，我们考虑下面条件和赋值表达式的通用形式

```cpp
v = test-expr ? then-statement : else-statement
```

基于条件控制的汇编器会得到如下代码：

```cpp
t = test-expr;
if(!t)
    goto false;
    v = then-statement;
	goto done;
false:
	v = else-statement;
done:
```

而基于条件传送的汇编器会得到如下代码：

```cpp
v = then-statement;
ve = else-statement;
t = test-expr;
if(!t)
    v = ve;
```

说明：并不是说使用条件传送就一定快过条件控制，并且有时候不能使用条件传送（原书 148 页），只不过是条件传送提供了一种替代条件控制的策略而已

​	 

### 循环

下面我们给出三种循环等价于汇编代码的 C 语言代码形式。但就哪一种循环更快而言，书中并没有进行过多的说明

#### do-while 循环

`do-while` 的通用语句为：

```cpp
do
    body-statement
    while(test-expr);
```

其等价于汇编的 C 语言形式为：

```cpp
loop:
	body-statement;
	t = test-expr;
	if(t)
        goto loop;
```

​	 

#### while 循环

`while` 语句的通用形式为：

```cpp
while(test-expr)
    body-statement
```

其等价于汇编的一种 C 语言形式为：

```cpp
	goto test;
loop:
	body-statement
test:
	t = test-expr;
	if(t)
        goto loop;
```

另一种形式被称为 *guarded-do* 策略，是通过条件控制和 `do-while` 循环一同实现的

```cpp
	t = test-expr;
	if(!t)
    	goto done;
loop:
	body-statement
	t = test-expr;
	if(t)
        goto loop;
done:
```

​	 

#### for 循环

`for` 循环的通用形式如下：

```c++
for(init-expr; test-expr; update-expr)
	body-statement
```

实际上，`for` 循环的行为与下面的 `while` 循环的行为是一致的

```cpp
init-expr
while(test-expr)
{
    body-statement
    update-expr
}
```

我们通过对 `while` 循环执行上面两种不同的解析策略，就能得到 `for` 循环的两种汇编表示，这里不过多赘述

​	 

## 过程

过程，在不同的编程语言当中的存在形式也不同：函数、方法、子进程、处理函数（handler）

为了对过程提供机器级的支持，我们需要提供下面三种机制。为了讨论方便，我们假设过程 P 调用过程 Q ，Q 执行完毕后返回到 P ，那么我们必须支持：

* 传递控制。在控制流从 P 到 Q 时，程序计数器必须被设置为过程 Q 的起始地址。在 Q 执行结束后，程序计数器必须被设置为调用过程 Q 语句后面那条指令的地址
* 传递参数。过程 P 可以向过程 Q 传递一个或多个参数（也可以不传），当过程 Q 返回时需要向过程 P 传递最多一个返回值
* 分配和释放内存。在过程 Q 开始时，需要为其局部变量分配内存。在过程 Q 结束时，我们需要将分配的内存释放

为了构建这些机制，我们按照控制、传递数据、内存管理的顺序来进行描述

​	 

### 运行时栈

我们通过栈这种数据结构来实现对过程的调用。对于一个过程而言，它在运行阶段一定会有各种信息（需要保存某个寄存器的值，分配局部变量空间，为将要调用的下一个过程设置参数等），那么我们可以在栈上单独给这个过程划分一块区域，该区域称为**过程的栈帧**

我们看上面的那个例子，当控制流执行到 Q 时，P 以及所有向上追溯到调用 P 的过程都会处于**挂起**状态。当过程 Q 运行时，它只需要在自己的栈帧当中处理数据即可。另一方面，当需要返回时，在它自己所处的栈帧将会被释放，这也同时达到了释放局部变量的目的，之后栈顶指针收缩，控制流会返回调用函数

具体地，当过程 P 调用过程 Q 时，会将会将返回地址压入栈中，指明当 Q 返回时程序需要从哪里开始执行。我们将这个返回地址当作过程 P 栈帧的一部分，因为这记录的是过程 P 的属性（从另一个角度项，如果这个地址存放在 Q 的栈帧内，那么在返回的时候该栈帧会释放，因而就无法找到返回值）。此后，栈顶指针减小为过程 Q分配空间。

在传递参数的部分，通过寄存器，P 可以向 Q 传递最多六个参数（这就是上面的第几个参数的由来），如果超过这个数，P 需要在调用 Q 之前在自己的栈帧内存储好，防止参数丢失（这里并不需要担心 Q 拿不到 P 的多余的参数，直接通过 MOV 指令复制过去就行并且这里的栈并不是严格遵循先进后出的）

​	 

### 控制转移

将控制从过程 P 转到过程 Q ，只需要将程序计数器的值设定为过程 Q 的起始地址即可，在返回的时候再将程序计数器的值设定为调用过程 Q 后面那条指令的地址即可。这一过程可以用两条指令来描述

|       指令       |       描述       |
| :--------------: | :--------------: |
|  $call\ Lable$   |     过程调用     |
| $call\ *Operand$ |     过程调用     |
|      $ret$       | 从过程调用中返回 |

指令 $call$ 会将地址 A 压入栈中，并把程序计数器的地址设置为过程 Q 的起始地址。地址 A 被称为返回地址，是跟在 $call$ 后面的那条指令的地址

​	 

### 参数传递

对于小于 6 个的参数的传递，这是通过寄存器来完成的

过程 P 调用过程 Q 之前，会先将参数复制到寄存器，然后再调用过程 Q ，而 Q 可以通过访问寄存器来得到参数

相应地，Q 的返回值也是通过寄存器传递给 P

对于大于 6 个的参数的传递，前面 6 个依旧是通过寄存器传递，后面的需要通过栈来传递。也就是，P 会将大于 6 个的参数复制到栈上（也就是自己的栈中，并且所有参数向 8 的倍数进行对齐），然后再调用 Q

这里其实可以结合实参和形参来进行理解。实参就是 P 的栈帧当中的局部变量，而形参则是 Q 的栈帧当中的局部变量，Q 需要从寄存器当中复制这些变量并在自己的栈帧当中开辟空间，这些空间也就是形参

​	 

### 调用者保存与被调用者保存

当 P 调用 Q 时，我们需要保证 Q 不会覆盖掉之后 P 需要使用的寄存器的值。也就是说，Q 需要保存 P 的部分寄存器并在返回时将这些寄存器设置为原来的值，这便是*被调用者保存*

一般来说，Q 会将某些寄存器的值压入栈中，之后便可以随意修改，在返回前将旧值弹出即可

同理，*调用者保存*是为了能够让 Q 随意地修改这个寄存器，以至于返回到 P 时，P 可以正常使用

其实调用者保存和被调用者保存的目的都是一样的，把二者区分开来我也不知道有什么用

​	 

### 数据对齐

其实内存对齐的目的是用空间换时间，牺牲掉部分空间利用率来得到更高效的寻址

内存对齐实际上是要求某种类型的数据的地址必须是 $K$ （通常是 2，4，8）的整数倍，原则上来说，$K$ 的大小取自该数据的字节大小。即任意 $K$ 字节大小的数据的内存地址必须为 $K$ 的整数倍
