---
title: CSAPP 第三章 程序的机器级表示
tags: CSAPP
categories: CSAPP
---

## 数据格式

我们采取 Intel 的标准，字（word）用来表示 16 位数据类型，因此 32 位也被称为 双字（double word），64 位被称为 四字（quad word）

|C声明|Intel 数据类型 |汇编代码后缀 | 大小（字节）|
|:---:|:--:|:--:|:--:|
|char|字节|b|1|
|short|字|w|2|
|int|双字|l|4|
|long|四字|q|8|
|char*|四字|q|8|
|float|单精度|s|4|
|double|双精度|l|8|

汇编指令都会有一个字符后缀，用来表示数据的大小。例如：movb（传送字节）、movw（传送字）、movl（传送双字）、movq（传送四字）

后缀 l 用来表示双字，这是因为 32 位数也被看成 长字（long word）

我们观察上表可以得出，后缀 l 同时表示了双字和双精度，但这并不会起冲突，因为浮点数的运算是一套完全不同的指令和寄存器

这里我们可以看出，所有的操作数都以一个统一的格式给出，每一种类型都对应一个后缀，这一点也为后续的数据传送提供了便利



## 访问信息

一个 x86-64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的通用目的寄存器，这些寄存器用来存储整数数据和指针

下表给出了所有寄存器，名称从左到右依次为 64 位、32 位、 16 位、 8 位

| 寄存器名称 | 作用 | 寄存器名称 | 作用 |
| :----: | :----: | :----: | :----: |
| %rax  %eax  $ax  %al | 保存返回值 | %rbx  %ebx  %bx  %bl | 被调用者保存 |
| %rcx  %ecx  %cx  %cl | 第 4 个参数 | %rdx  %edx  %dx  %dl | 第 3 个参数 |
| %rsi  %esi  %si  %sil | 第 2 个参数 | %rdi  %edi  %di  %dil | 第 1 个参数 |
| %rbp  %ebp  %bp  %bpl | 被调用者保存 | %rsp  %esp  %sp  %spl | 栈指针 |
| %r8  %r8d  %r8w  %r8b | 第 5 个参数 | %r9  %r9d  %r9w  %r9b | 第 6 个参数 |
| %r10  %r10d  %r10w  %r10b | 调用者保存 | %r11  %r11d  %r11w  %r11b | 调用者保存 |
| %r12  %r12d  %r12w  %r12b | 被调用者保存 | %r13  %r13d  %r13w  %r13b | 被调用者保存 |
| %r14  %r14d  %r14w  %r14b | 被调用者保存 | %r15  %r15d  %r15w  %r15b | 被调用者保存 |

我们详细解释一下这些寄存器的作用

保存返回值是指，用于保存函数调用时的返回值

栈指针是指栈顶指针

第 $i$ 个参数是指，在函数调用时，需要传递函数参数，当函数参数小于 6 时由寄存器保存，大于 6 个的部分由栈帧保存

调用者保存以及被调用者保存的意思是，这个寄存器的值可以被调用者或者被调用者修改，但又必须保证该寄存器的值不变，因此需要调用者或者被调用者保存在自己的栈帧内

出于向前兼容的特性，当我们向这些寄存器当中写入小于 8 字节的值，剩下的字节变化按照下面两条规则来：

生成 1 字节和 2 字节的指令，会保证剩下的字节不变

生成 4 字节的指令会将高位 4 字节全部置零

### 操作数指示符

大多数指令有一个或者多个操作数，操作数是指一个操作当中需要使用的**源数据值**和放置结果的**目的地址**

源数据值可以以常数的形式给出，也可以通过访问寄存器或内存来读取。目的地址可以是寄存器也可以是内存。因此，操作数可以被划分为三种类型：

* 立即数（immediate），用来**直接给出常数值**。立即数的书写是在 $ 后面跟一个 C 语言的整数
* 寄存器，通过访问某个寄存器得到其内容，当然是允许间接访问的。我们将寄存器集合看成一个数组 $R$ ，用寄存器标识符作为数组索引。即用 $r_a$ 来表示任意寄存器 $a$ ，用 $R[r_a]$ 来表示该寄存器的值
* 内存引用，会根据计算出来的地址来访问某个特定的内存，也允许间接访问。我们将内存看成一个很大的字节数组，我们用 $M_b[Addr]$ 来表示存储在内存中从 $Addr$ 地址处的 $b$ 个字节的内存引用。为了描述方便，我们通常会省略下标 $b$ 

关于内存寻址，这里我们给出最一般的情况，即：$Imm(r_b,r_i,s)$ 用来表示 $M[Imm+R[r_b]+R[r_i]\cdot s]$ ，其中 $Imm$ 为立即数偏移，$r_b$ 为基址寄存器，$r_i$ 为变址寄存器，$s$ 为比例因子，其值只能是1、2、4、8

​	 

### 数据传送指令

该指令会将数据从一个位置**复制**到另一个位置

下面我们给出数据传送指令—— $MOV$ 类，它们会将数据从源位置**复制**到目标位置而不做任何变化

$MOV$ 类指令由四条基本指令构成，它们之间的区别在于操作的数据大小不同

当然，源操作数的大小可以不按照传送指令标识出的大小，比如我可以用 movq 来传送双字，只不过这样会将高位的 2 个字节传送而已。不过这四条不建议这么使用，因为对于这种源小于目的的情况，会有专门的传送指令来实现

|     指令     |     效果     |      描述      |
| :----------: | :----------: | :------------: |
| $MOV\ S,\ D$ | $D\ \gets S$ |      传送      |
|     movb     |              |    传送字节    |
|     movw     |              |     传送字     |
|     movl     |              |    传送双字    |
|     movq     |              |    传送四字    |
|   movabsq    |              | 传送绝对的四字 |

源操作数的值可以是一个立即数、存储在寄存器或内存当中的值。目的操作数指定一个位置，要么是寄存器，要么是内存地址。并且传送指令的两个操作数不能都指向内存地址

对于常规的四条 $MOV$ 指令，它们是以补码的形式看到源数据，如果传送的数据大小大于源数据，它们会将源数据传送到目的地，并**将高位按照补码的规则补充**。而 movabsq 是以无符号来传输四字的，并且是以 64 位立即数来作为源操作数，以寄存器作为目的

对于源小于目的的情况，可以使用 $MOVZ$ 和 $MOVS$ 来实现。对于前者，它会将剩余字节全部填充 0 ，对于后者，它会将剩余字节按符号进行填充，即对源操作数的最高位进行复制

|     指令      |         效果         |           描述           |
| :-----------: | :------------------: | :----------------------: |
| $MOVZ\ S,\ R$ | $R\ \gets (零拓展)S$ |     以零拓展进行传送     |
|    movzbw     |                      | 前一个为源，后一个为目的 |
|    movzbl     |                      |                          |
|    movzwl     |                      |                          |
|    movzbq     |                      |                          |
|    movzwq     |                      |                          |

$MOVZ$ 指令只能以寄存器或内存地址作为源，以寄存器作为目的

|     指令      |              效果              |          描述           |
| :-----------: | :----------------------------: | :---------------------: |
| $MOVS\ S,\ R$ |     $R\ \gets (符号拓展)S$     |   传送符号拓展的字节    |
|    movsbw     |                                |                         |
|    movsbl     |                                |                         |
|    movswl     |                                |                         |
|    movsbq     |                                |                         |
|    movswq     |                                |                         |
|    movslq     |                                |                         |
|     cltq      | $\%rax\ \gets (符号拓展)\%eax$ | 把 %eax 符号拓展到 %rax |

$MOVS$ 类指令只能以寄存器或内存地址作为源，以寄存器作为目的。cltq 指令只能作用于寄存器 %eax 和 %rax

​	 

### 压入和弹出栈数据

程序栈存放在内存当中的某个区域，**栈向下增长**，栈顶元素的地址是所有栈中元素地址中最低的，栈指针 %rsp 保存着栈顶元素的地址

下面两条指令可以将数据压入程序栈在以及从程序栈中弹出数据

|    指令    |                       效果                        |                    描述                     |
| :--------: | :-----------------------------------------------: | :-----------------------------------------: |
| $pushq\ S$ | $R[\%rsp]\gets R[\%rsp]-8\ ;\ M[R[\%rsp]]\gets S$ |   先将栈顶指针下移，再将四字 $S$ 压入栈中   |
|  $pop\ D$  | $D\gets M[R[\%rsp]]\ ;\ R[\%rsp]\gets R[\%rsp]+8$ | 先将栈顶元素弹出到 $D$ 中，再将栈顶指针上移 |

​	 

## 算术和逻辑操作

下面我们给出对于整数的算术和逻辑操作，当然这些指令大多有操作数大小的变种（除了 leaq 没有）。就比如，ADD 指令可以分为 addb、addw、addl、addq 等

|     指令      |          效果          |        描述        |
| :-----------: | :--------------------: | :----------------: |
| $leaq\ S,\ D$ |    $D\ \gets\ \&S$     |    加载有效地址    |
|   $INC\ D$    |    $D\ \gets\ D+1$     |        加 1        |
|   $DEC\ D$    |    $D\ \gets\ D-1$     |        减 1        |
|   $NEG\ D$    |     $D\ \gets\ -D$     |        取负        |
|   $NOR\ D$    |   $D\ \gets\ \sim D$   |        取补        |
| $ADD\ S,\ D$  |    $D\ \gets\ D+S$     |         加         |
| $SUB\ S,\ D$  |    $D\ \gets\ D-S$     |         减         |
| $IMUL\ S,\ D$ | $D\ \gets\ D\times S$  |         乘         |
| $XOR\ S,\ D$  | $D\ \gets\ D \oplus S$ |        异或        |
|  $OR\ S,\ D$  |  $D\ \gets\ D\ |\ S$   |         或         |
| $AND\ S,\ D$  |  $D\ \gets\ D\ \&\ S$  |         与         |
| $SAL\ k,\ D$  |    $D\ \gets\ D<<k$    |        左移        |
| $SHL\ k,\ D$  |    $D\ \gets\ D<<k$    | 左移，等同于 $SAL$ |
| $SAR\ k,\ D$  |  $D\ \gets\ D>>_{A}k$  |      算术右移      |
| $SHR\ k,\ D$  |  $D\ \gets\ D>>_{L}k$  |      逻辑右移      |

加载有效地址（load effective address）指令 leaq ，可以从内存当中读取数据到寄存器当中。但实际上它并不会引用内存（也就是读取内存当中某个值的意思），它只会将该内存的**地址**赋值给寄存器，因此我们用 C 语言的地址引用操作符来描述这个过程

举个例子，如果寄存器 $\%rdx$ 的值为 $x$ （这里的 $x$ 是内存当中的某个地址，是间接寻址），那么 $leaq 7(\%rdx, \%rdx, 4) \%rax$ 表示，将寄存器 $\%rax$ 的值设置成 $5x$ ，这里的 $5x$ 是一个内存地址，也就是我需要通过 $M[5x]$ 才能找到我需要的值
