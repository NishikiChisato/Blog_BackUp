---
title: CSAPP 第二章 信息的表示和处理
tags: CSAPP
categories: CSAPP
---

## 信息存储

大多数计算机使用 8 位的字节作为**最小的可寻址的内存单位**，而不是直接访问内存当中单独的位（或者说比特）。机器级程序会将内存视为一个非常的字节数组，这个内存称为*虚拟内存*。内存当中的**每个字节**都用唯一的数字来进行标识，这称为该字节的*地址*，所有可能的地址集合就是*虚拟地址空间*。

这里的虚拟地址空间只是给机器级程序的一个**概念性**的映射，具体的底层实现由硬件来处理。



### 寻址和字节顺序

我们知道，一个对象肯定不可能只占一个字节，那么对于多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存当中该如何存储这些字节。

多字节对象大多被存储为**连续**的字节序列，该对象的地址就是所使用的连续的字节序列当中**最小**的地址。例如，一个 `int` 类型的变量占 4 个字节，分别是 0x100 、0x101、0x102、0x103，那么在这里面，0x100 就是这个变量的地址。

我们考虑一个有 **$\omega$ 位**的整数，其位表示为 $[\ x_{\omega-1},\ x_{\omega-2},\ \cdots,x_1\ ,x_0\ ]$ 。我们假设 $\omega$ 是 8 的倍数（不够的位数补 0 ） ，那么该整数的最高**字节**为 $[\ x_{\omega-1},\ x_{\omega-2},\ \cdots,\ x_{\omega-7},\ x_{\omega-8}\ ]$ ，最低位**字节**为 $[\ x_7,\ x_6,\ \cdots,\ x_1,\ x_0\ ]$ 。如果一台机器将**低位有效字节存储低地址**处（0x100 处），那么该机器为**小端存储**，如果将**高位有效字节存储在低地址**处，那么为大端**存储**。



### 布尔运算

我们给出四种最基本的布尔运算结果：

|~||      |  &   | 1 | 0 |    | \| |1|0||^|1|0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|0|1||1|1| 0 |      | 1 |1|1||1|0|1|
|1|0||0|0| 0 |      | 0 |1|0||0|1|0|

我们着重说一下异或，只有当 $P$ 、$Q$ 不同时为真时，$P \oplus Q$ 才为真。

整数运算的一个属性是每一个数都存在一个加法逆元 $-x$ ，使得 $x\ + \ (-x)\ =\ 0$ 。在布尔运算里面也有相同的属性，这里面的加法就是异或 $\oplus$ 。

对任意值 $a$ 而言，有 $a \ \oplus \ a \ =\ 0$  、$a\ \oplus \ 0 \ =\ a$ 。

并且异或类似于集合当中的补集，举个例子就是：

 $0x11223344\ \oplus\ 0\ =\ 0x11223344$ 、$0x87654321\ \oplus \ 0xffffffff\ =\ 0x789abcde$ 

即 8 + 7 = 15 、9 + 6 = 15 、1 + e = 15，所以说异或具有补集的性质。



### 逻辑运算与移位操作

上面的布尔运算属于**位级运算**的范畴，跟逻辑运算完全不一样

逻辑运算认为所有的非零参数都表示 TRUE ，而 0 表示 FALSE ，因此便有了下面的这些运算结果：

|!0x41|0x00|
|:-:|:-:|
|!!0x41|0x01|
|0x41 && 0x42|0x01|
|0x41 \|\| 0x42|0x01|

这里的移位操作我们专指 C 语言

对于一个位表示为 $[\ x_{\omega-1},\ x_{\omega-2},\ \cdots,\ x_1,\ x_0\ ]$ 的数，如果我们对其**左移** $k$ 位，其结果为 $[\ x_{\omega-k-1},\ x_{\omega-k-2},\ \cdots,\ x_0,\ 0,\ \cdots,\ 0\ ] $ 。就结果而言，最右端补 $k$ 个 0 是显然的。但如果是右移情况会有那么一点不一样

右移分为两种：逻辑右移和算术右移。对于逻辑右移，左边会补 $k$ 个 0 ；对于算术右移，左端会补 $k$ 个最高有效位的值（最高位是 1 就全补 1 ，最高位是 0 就全补 0 ）



## 整数表示

关于定义的数学描述，建议去看原书第 42 页，这里不过多赘述



### 无符号数的编码

假设一个整数数据类型有 $\omega$ 位。我们可以将位向量写成 $\vec{x}$ ，用来表示整个向量，或者将位向量写成 $[\ x_{\omega-1},\ x_{\omega-2},\ \cdots,\ x_1,\ x_0\ ]$ ，来表示这个向量当中的每一位。这样，我们便获得了一个整数的二进制表示

在这个编码中，每个 $x_i$ 既可以是 0 也可以是 1 

基于此，我们便得到了一个无符号数的编码定义：

对于向量 $\vec{x}\ =\ [\ x_{\omega-1},\ x_{\omega-2},\ \cdots,\ x_1,\ x_0\ ]$ 而言，有：

$B2U_\omega\ \doteq\ \sum_{i\ =\ 0}^{\omega\ -\ 1}x_i2^i$ 



### 补码数的编码

下面，我们给出补码的定义：

对于向量 $\vec{x}\ =\ [\ x_{\omega-1},\ x_{\omega-2},\ \cdots,\ x_1,\ x_0\ ]$ 而言，有：

$B2T_\omega\ \doteq\ -x_{\omega-1}2^{\omega-1}\ +\ \sum_{i\ =\ 0}^{\omega\ -\ 2}x_i2^i$

**对于有符号数而言，一般都是采用补码编码**

关于补码具体的数值，可以去看原书 46 页。我们在此需要说明一点是：$|TMin_\omega|\  =\ |TMax_\omega|\ +\ 1$ ，原因在于补码将数划分为负数和非负数，而 0 需要算在非负数里面，因此就造成二者绝对值少 1 的情况

下面我们给出有符号数的其他两种表示方法

**反码**（Ones' Complement）：$B2O_\omega\ \doteq\ -(x_{\omega-1}2^{\omega-1}\ -\ 1)\ +\ \sum_{i\ =\ 0}^{\omega\ -\ 2}x_i2^i$ 

所以说反码加 1 等于补码

**原码**（Sign-Magnitude）：$B2S_\omega\ \doteq\ (-1)^{x_{\omega-1}}\ \cdot\ (\sum_{i\ =\ 0}^{\omega\ -\ 2}x_i2^i)$ 

不难看出，原码是将最高位当作符号位，并不表示大小

原码有一个问题是会将 $[00 \cdots 0]$ 与 $[10 \cdots0]$ 都解释为 0 



### 拓展一个数字的位表示

对于无符号数的转换，只需要简单地在开头添加 0 ，这也被称为零拓展

无符号数的零拓展：

定义宽度为 $\omega$ 的位向量 $\vec u\ =\ [\ u_{\omega-1},\ u_{\omega-2},\ \cdots,\ u_1,\ u_0\ ]$ 和宽度为 $\omega'$ 的位向量 $u'\ =\ [\ {\color{violet}0},\ {\color{violet}0},\ \cdots,\ {\color{violet}0},\ u_{\omega-1},\ u_{\omega-2},\ \cdots,\ u_1,\ u_0\ ]$  ，其中 $\omega'\ >\ \omega$ ，有：$B2U_{\omega}(\vec u)\ =\ B2U_{\omega'}(\vec u')$ 

补码数的符号拓展：

定义宽度为 $\omega$ 的位向量 $\vec u\ =\ [\ u_{\omega-1},\ u_{\omega-2},\ \cdots,\ u_1,\ u_0\ ]$ 和宽度为 $\omega'$ 的位向量 $u'\ =\ [\ {\color{violet}u_{\omega-1}},\ {\color{violet}u_{\omega-1}},\ \cdots,\ {\color{violet}u_{\omega-1}},\ u_{\omega-1},\ u_{\omega-2},\ \cdots,\ u_1,\ u_0\ ]$  ，其中 $\omega'\ >\ \omega$ ，有：

$B2T_{\omega}(\vec u)\ =\ B2T_{\omega'}(\vec u')$ 

这个的证明很妙，去看原书第 55 页



### 截断数字

截断无符号数：

设 $\vec x\ =\ [\ x_{\omega-1},\ x_{\omega-2},\ \cdots,\ x_0\ ]$ ，而 $\vec x'$ 为将其截断**为** $k$ 位后的结果，即 $\vec x'\ =\ [\ x_{k-1},\ x_{k-2},\ \cdots,\ x_1,\ x_0\ ]$ 。我们令 $x\ =\ B2U_{\omega}(\vec x)$ ，$x'\ =\ B2U_{k}(\vec x')$ ，有：

$x'\ =\ x\ mod\ 2^k$    



这个的证明也很秒，这里简单说一下

由于无符号值是通过加法一个一个加起来的，而我们模 $k$ 的话，位数小于 $k$ 的还是原来的数，位数大于等于 $k$ 的全部变成零

太妙了



截断补码数值：

设 $\vec x\ =\ [\ x_{\omega-1},\ x_{\omega-2},\ \cdots,\ x_0\ ]$ ，而 $\vec x'$ 为将其截断**为** $k$ 位后的结果，即 $\vec x'\ =\ [\ x_{k-1},\ x_{k-2},\ \cdots,\ x_1,\ x_0\ ]$ 。我们令 $x\ =\ B2U_{\omega}(\vec x)$ ，$x'\ =\ B2T_{k}(\vec x')$ ，有：

$x'\ =\ U2T_k(x\ mod\ 2^k)$ 



简单来说，对于补码的截断，我们**先对其做无符号截断，再从补码的角度看待剩下的位向量**即可（括号里面是无符号截断，外面的 $U2T$ 是从补码的角度进行翻译）

 

## 整数运算

需要说明的是，我们在这里只会给出整数运算的定义以及具体实现，关于其底层数学证明，我是智障，我看不懂



### 无符号加法

我们先给出其数学表达式：

我们定义符号 $+^{u}_{\omega}$ 表示对两个 $\omega$ 位的无符号数进行加法，则：

对满足 $0\le\ x,\ y\ <2^{\omega}$ 的 $x$ 和 $y$ ，有：

$x\ +^{u}_{\omega}\ y\ =\ \begin{cases} x\ +\ y,&x\ +\ y\ <\ 2^{\omega}\\ x\ +\ y\ -2^{\omega},&\ 2^{\omega}\ \le\ x\ +\ y\ <\ 2^{\omega+1} \end{cases}$

对于其位运算，我们直接将二者相加，再对其进行**截断**即可

我们给出位运算表达式，其中 $x$ 与 $y$ 均为**无符号数**，有：

$x+^u_{\omega}y=(x+y)\ mod\ 2^{\omega}$ 



#### 关于无符号数加法溢出的检测

设 $0\le x,\ y\le UMax_{\omega}$ ，我们令 $s=x+^{u}_{\omega}y$ ，当且仅当 $s < x$ （或者等价条件 $s<y$）时，加法溢出

这个证明很简单，原书 62 页



### 无符号的非

无符号的非的意思是，在保证为 $\omega$ 位的情况下，求一个数 $x$ ，使得 $x+a=0$ ，其中 $a$ 为已知数

对满足 $0\le x<2^{\omega}$ 的任意 $x$ ，其 $\omega$ 位的无符号逆元 $-_{\omega}^{u}\ x$ 由下式给出：

$-^{u}_{\omega}\ x=\begin{cases} x,&x=0\\2^{\omega}-x,&x>0 \end{cases} $



### 补码加法

数学表达式为：

对满足 $-2^{\omega-1} \le x,\ y\le 2^{\omega-1}-1$ 的整数 $x$ 和 $y$ ，有：

$x+^{t}_{\omega}y=\begin{cases} x+y-2^{\omega},&2^{\omega-1}\le x+y&\text{正溢出}\\x+y,&-2^{\omega-1}\le x+y<2^{\omega-1}&\text{正常}\\x+y+2^{\omega},&x+y<-2^{\omega-1}&\text{负溢出} \end{cases}$



对于其位运算的具体操作：我们先将二者做无符号加法并将其截断，最后将结果转换成补码

我们给出如下位运算表达式，其中 $x$ 与 $y$ 均为**补码数**，有

$x+^t_{\omega}y=U2T_{\omega}(T2U(x)_{\omega}+^u_{\omega}T2U_{\omega}(y))$





#### 补码加法溢出的检测

设 $TMin_{\omega}\le x,\ y\le TMax_{\omega}$ ，令 $s=x+^{t}_{\omega}y$ 

注意到，当发生正溢出时，$s<0$ ；当发生负溢出时，$s>0$ ，因此：

当 $x>0,\ y>0,\ s\le 0$ 或者 $x<0,\ y<0,\ s\ge 0$ 时，补码加法发生溢出

C++代码为：

```cpp
bool tadd(int x, int y)//overflow return 0 , else return 1
{
    int sum = x + y;
    return !(x > 0 && y > 0 && sum <= 0) && !(x < 0 && y < 0 && sum >= 0)
}
```

这里补充一点：

对于等式：$(x+y)-(x+y)=0$ 而言，**不管加法是否溢出，该式子都成立**

我们将其移位，得到：$(x+y)-x=y$ 无论**加法是否溢出，这都成立**

所有，如果我们需要检测补码加法是否溢出时，**不能**这么写：

```cpp
bool tadd(int x, int y)
{
    int sum = x + y;
    return (sum - x == y) && (sum - y == x);
}
```

这写的，我能笑一天的那种



### 补码的非

原理同无符号的非，求一个数 $x$ 在补码的条件下与已知数 $a$ 相加得零的值，即：$x+a=0$ 

对满足 $TMin_{\omega} \le x \le TMax_{\omega}$ 的 $x$ ，其补码 $-^{t}_{\omega}x$ 由下式给出：

$-^{t}_{\omega}x=\begin{cases} TMin_{\omega},&x=TMin_{\omega}\\-x,&x>TMin_{\omega} \end{cases}$

无论是无符号的非，还是补码的非，实际上都是为了将减法运算转换为加法

就比如，考虑两个补码位向量 $\vec u$ 和 $\vec v$ ，当我们试图计算 $B2T(\vec u-^{t}_{\omega}\vec v)$ 时（这里我们以补码视角看待最终结果）

由于我们定义了补码的非，上式实际上等价为：

$B2T_{\omega}(\vec u-^{t}_{\omega}\vec v)=B2T_{\omega}(\vec u+^{t}_{\omega}(-^{t}_{\omega}x))$

由于 $\vec u$ 和 $-^t_{\omega}x$ 均可以**单独算出一个值**，因此这便成了两个补码数的加法，按照加法原则相加即可



#### 补码非位级的快速计算

考虑一个问题：假设我已知一个补码的位级表示，如何快速求出其非的位级表示

一个显而易见的结果是：先对其每一位取反，再将结果加 1 ，即：

$-x=(\sim x)+1$

这是最朴素的做法，其实还有一种更加方便的

考虑一个位向量 $\vec x\ =\ [\ x_{\omega-1},\ x_{\omega-2},\ \cdots,\ x_0\ ]$ 。假设从右边数第一个为 1 的数是第 $k$ 位，即：$\vec x\ =\ [\ x_{\omega-1},\ x_{\omega-2},\ \cdots,\ x_0\ ]\ =\ [\ x_{\omega-1},\ x_{\omega-2},\ \cdots,\ 1,\ 0,\ 0,\ \cdots,\ 0]$ 

那么，我们只需要从第 $k+1$ 位起将左边的位全部取反

例如：$[1101]=-3,\ [0011]=3$ 



### 无符号乘法

无符号乘法可以表述为：将两个数先相乘再对其结果做 $\omega$ 位数截断，数学定义如下：

设 $0\le x,\ y\le UMax_{\omega}$ ，有：

$x*^{u}_{\omega}y=(x*y)\ mod\ 2^{\omega}$ 



### 补码乘法

补码乘法相当于先将两个数做无符号乘法，再从补码的角度去看待结果，其数学定义如下：

设 $TMin_{\omega}\le x,\ y\le TMax_{\omega}$ ，有：

$x*^{t}_{\omega}y=U2T_{\omega}((x*y)\ mod\ 2^{\omega})$ 



### 乘以常数

我们首先来讨论乘以 $2^k$ 的情况

设无符号数 $x$ 和 无符号数 $k$ ，运算 $x<<k$ 的值等价于 $x*^u_{\omega}2^k$ （这里会自动做位数截断）

设补码数 $x$ 和无符号数 $k$ ，运算 $x<<k$ 的值等价于 $x*^t_{\omega}2^k$ 

也就是说，对于无符号数与补码数而言，乘以 $2^k$ ，相当于将其对应的位向量左移 $k$ 位

接着，我们来讨论乘以任意数 $K$ 的情况

在给出具体分析之前，我们首先要知道一点：CPU 计算加法、减法、移位的速度远快于直接计算乘法除法等运算，因此我们需要尽可能将乘以任意数 $K$ 转化成加法、减法、移位的运算

对于任意数 $K$ ，我们可以很轻易地给出其位向量 $\vec k=[k_{\omega-1},\ k_{\omega-2},\cdots,\ k_1,\ k_0]$ ，也就是说，$K$ 可以表示为

$K=\sum^{\omega-1}_{i=0}k_i2^k$ ，那么我们便可以通过移位来描述这个过程：

$x*K=x*\sum^{\omega-1}_{i=0}k_i2^k=\sum^{\omega-1}_{i=0}(x<<k_i)$ 

举个例子：

$K=[1010]$ ，那么 $x*K=(x<<3)+(x<<1)$ 

$K=[1011]$ ，那么 $x*K=(x<<3)+(x<<1)+(x<<0)=(x<<3)+(x<<1)+x$ 

我们用更一般化的语言来描述这个过程，考虑一组从位位置 $n$ 到位位置 $m$ 的一组**连续**的 1 （$14=(0\cdots 0)(111)(0)$，在这里，$n=1,\ m=1$）

那么，$x*K$ 可以有下面两种表述：

$x*K=(x<<n)+(x<<(n-1))+\cdots+(x<<m)$ 

$x*K=(x<<(n+1))-(x<<m)$ 

到此为止，我们给出了乘以任意数的数学表述



### 除以 2 的幂

我们定义 $\lfloor x \rfloor$ 表示 $x-1\le \lfloor x \rfloor<x$ ，$\lceil x \rceil$ 表示 $x-1<\lceil x \rceil \le x$ ，我们有如下结论：

对于正数，除法为向下舍入，即 $x>0,\ y>0$ ，有：$x/y=\lfloor x/y\rfloor$ 

对于负数，除法为向上舍入，即 $x>0,\ y<0$ ，有：$x/y=\lceil x/y\rceil$ 

这里的证明，去看原书 72 页

设无符号数值 $x$ 和无符号数值 $k$ ，运算 $x>>k$ 的值等价于 $\lfloor x/2^k \rfloor$ 

对于补码数值 $x$ 和无符号数值 $k$ ，运算 $(x+(1<<k)-1)>>k$ 的值等价于 $\lceil x/2^k \rceil$ 

这里的证明，去看原书 73 页

例如，假设 $k=4$ ，那么 $x/2^4=(x+(1<<4)-1)>>4=(x+15)>>4$ 

除以 2 的幂，我们可以用移位来解决，但除以任意数的话，并不能通过这种方式来实现

​	 

## 浮点数

### IEEE 浮点表示

核心为用：$(-1)^s\times M\times 2^E$ 来表示一个浮点数

* 符号（sign）， $s$ 用于决定这个数是正数（$s=0$） 或者是负数（$s = 1$），而对于数值 0 的位解释作为特殊情况处理
* 尾数（significand），$M$ 是一个二进制小数，它的范围为 $0\sim 1- \varepsilon$ 或者 $1\sim 2-\varepsilon$ 
* 阶码（exponent），$E$ 的作用是对浮点数加权，权重是 2 的 $E$ 次幂

下面我们给出 32 位与 64 位的编码示例：

对于单精度而言，符号位占 1 位，阶码位占 8 位，尾数位占 23 位

对于双精度而言，符号位占 1 位，阶码位占 11 位，位数位占 52 位

当给定一个浮点数的位表示时，浮点数值的解读分为三种不同情况（我们以单精度为例，第三种情况有两个变种）

1. 规格化的

阶码字段**既不为全 0 也不为全 1** ，对尾数字段不做要求

2. 非规格化的

阶码字段为**全 0**，对尾数字段不做要求

3. a 无穷大

阶码字段为**全 1** ，尾数字段为**全 0** 

3. b NaN

阶码字段为**全 1**，尾数字段不为**全 0**

下面我们给出对于三种情况下的位数解析

#### 规格化的情况

##### 阶码字段

设阶码字段位表示为 $exp=e_{k-1}e_{k-2}\cdots e_1e_0$ （$k$ 位），$exp$ 不为全 0 （数值 0 ）也不为全 1 （单精度为 255 ，双精度为 2047）时属于这种情况

阶码的值 $E=e-Bias$ ，其中 $e$ 为 $exp$ 的无符号位表示，$Bias$ 是一个等于 $2^{k-1}-1$ 的数值（单精度为 127 ，双精度为 1023 ）的偏置值

也就是说，**实际的阶码值等于以无符号方式解析位表示得到的值减去一个偏置值**

由此，我们便可以得到一个指数的范围，对于单精度：$-126\sim +127$ ，对于双精度：$-1022\sim +1023$ 

##### 尾数字段

设尾数字段的位表示为 $frac=f_{n-1}f_{n-2}\cdots f_1f_0$ ，该字段用于描述小数值 $f$ ，其中 $0\le f < 1$ 

小数值 $f$ 的位表示为 $0.f_{n-1}f_{n-2}\cdots f_1f_0$ ，即二进制小数点在最高有效位的左边

尾数字段的定义为 $M=1+f$ ，我们将先导的 1 省略掉，这样可以节省一个位的空间

#### 非规格化的值

当阶码字段为全 0 时，属于这种情况

阶码值为 $E=1-Bias$ ，其中 $Bias=2^{k-1}-1$ 

尾数值为 $M=f$ 

单独规定一个非规格化的数值有两个好处

第一个是它提供了一种表示数值 0 的方式。当我们按照规格化的方式来表示数值 0 的时候，需要将所有位全部置零，但由于规格化的尾数字段会加一个先导的 1 ，因此它很难真正表示出 0 （只能是近似）。除此之外，当符号位为 1 ，其它位为全 0 的时候，它也会表示 0 ，因此这就导致了 0 会有两种表示，这显然是不好的

第二个是它可以去表示那些非常近似到 0 的数。在趋近 0 的部分，数值分布是较为平均的，这种属性被称为*逐渐下溢*

#### 特殊值

当阶码字段为全 1 时出现这种情况

当尾数字段为全 0 时，会得到无穷。当 $s=1$ 时，得到 $-\infty$ ，当 $s=0$ 时，得到 $+\infty$ 

当尾数字段为非 0 时，得到 NaN。

​	 

最后我们简单说一下在 C 语言当中的符号转换出现的精度损失问题

当非浮点数向浮点数转换时，只要后者表示的范围大于前者，那么就没问题，如果后者的范围小于前者，那么会舍入

当浮点数向非浮点数转换时，值会向零舍入（正数向下，负数向上）

从 double 转 float 时，所得值可能会溢出到无穷，或者会被舍入

