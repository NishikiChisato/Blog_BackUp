---
title: 二分、前缀和、差分总结
tags: [二分, 前缀和, 差分, 总结]
categories: AcWing
---

## 二分

我们通常所理解的二分是「二分查找」，也就是在一个单调的数组当中寻找一个数

那我们思考一个问题：**二分的本质是单调性吗？**换句话说，一定要满足「单调」才可以二分吗？

答案是否定的，实际上二分的本质是**「性质」**

我们将一个数组划分为两部分，这两部分**没有交集**。其中，前半部分满足「性质 $p$ 」，后半部分不满足「性质 $p$ 」

那么，这两部分的分界点有两个，我们的**二分就是用来求这两个分界点的**

记住，二分是通过**不断改变左右区间**来**求分界点的**

举个例子，我们将区间 $[0,9]$ 划分为 $[0,4],\ [5,9]$ ，二者没有交集，那么我们可以用二分来求出分界点 $4$ 和 $5$ （我们求左端点 $4$ ）

具体地，我们定义左区间满足「性质 $p$ 」，右区间不满足「性质 $p$ 」，那么有：

如果当前 `mid` 满足「性质 $p$ 」，那么说明 `mid` 在左区间，我们要调整**左端点**才可以求出我们需要的左端点，也就是 `l = mid` 

相应地，如果 `mid` 不满足「性质 $p$ 」，说明 `mid` 在右半边，那么我们需要调整**右端点**，即 ``r = mid - 1`

具体地，二分有两个模板，都可以求出两个边界

```cpp
//将区间[l, r]划分为[l, mid], [mid + 1, r]
bool check(int mid);//检查mid是否具有性质p
int bserch_l(int l, int r)//找左边界，设左区间满足性质p
{
    while(l < r)
    {
        int mid = l + r + 1>> 1;
        if(check(mid)) l = mid;
        else r = mid - 1;
    }
    if(check(l)) return -1;//不满足题意
    else return l;//返回l或者r都行，因为二分最后一定会收敛到一个值
}

//将区间[l, r]划分为[l, mid - 1], [mid, r]
int bserch_r(int l, int r)
{
    while(l < r)
    {
        int mid = l + r >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    if(check(l)) return -1;
    else return l;
}
```

​	 

## 前缀和

前缀和可以**快速**求出一个区间当中的**数字和**，时间复杂度为 $O(1)$ 

需要注意的是，前缀和数组必须从 1 开始，并且索引为 0 的值必须为 0

具体地，我们令 $a[i]$ 为原数组，$b[i]$ 为前缀和数组，有：
$$
b[i]=b[i-1]+a[i]
$$
其中 $a$ 与 $b$ 数组当中的数**均是从索引为 1 的地方开始存储**（这个条件很关键啊）

显然，$b[i]$ 表示的意思是 $a[i]$ 及之前所有数的加和（这里是包括 $a[i]$ 的）

因此当我们要求一个区间 $[l,\ r]$ 的和时，有：
$$
S_{l,r}=b[r]-b[l-1]
$$
相应地，我们可以将前缀和拓展到二维，同样是**从 1 开始存储数据**，有：
$$
b[i][j] = b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1] + a[i][j]
$$
当我们需要求点 $(x_1, y_1)$ 到点 $(x_2,y_2)$ 所围成的矩形的数字和时，有：
$$
S_{(x_1,y_1),\ (x_2,y_2)} = b[x_2][y_2] - b[x_1-1][y_2] - b[x_2][y_1-1] + b[x_1-1][y_1-1]
$$
​	 

## 差分

差分是前缀和的逆运算

我们现在有一个数组 $a[i]$ ，我们通过该数组来构造一个数组 $b[i]$ ，使得：
$$
b[1]+b[2]+\cdots +b[i]=a[i]
$$
即 $b[i]$ 数组的前缀和为 $a[i]$ 数组，那么我们称数组 $b[i]$ 为数组 $a[i]$ 的**差分数组**

差分数组可以**快速让数组内的某个区间加上同一个数** $v$ ，时间复杂度为 $O(1)$ 

关于差分数组，我们并不需要像前缀和那样给出一个递推公式，我们一开始将 $a[i]$ 数组看成全 0 ，然后对 $a[i]$ 数组赋值的过程就可以看成是对差分数组构造的过程，只不过是区间长度为 1 的构造而已

我们定义一个 `insert` 函数，每次对区间长度为 1 的区间进行增加，增加值为 `a[i]` ，这样便可以构造出差分数组

由于差分数组 $b[i]$ 是数组 $a[i]$ 的前缀和，因此对 $b[i]$ 增加一个数会导致 $a[i]$ 以及后面的所有数都增加同一个值，有：

如果我们需要让数组 $a[i]$ 中区间 $[l,r]$ 增加同一个数 $v$ ，那么有：
$$
b[l] += v;\\
b[r + 1] -= v;
$$
因此我们的 `insert` 函数可以写成：

```cpp
void insert(int l, int r, int v)
{
    b[l] += v;
    b[r + 1] -= v;
}
```

相应地，我们也可以将差分推广到二维，作用是将一个矩形区域内的所有数加上同一个数

插入函数我们写成：

```cpp
void insert(int x1, int y1, int x2, int y2, int v)
{
	b[x1][y1] += v;
    b[x2 + 1][y1] -= v;
    b[x1][y2 + 1] -= v;
    b[x2 + 1][y2 + 1] += v;
}
```

我们对差分数组求**前缀和就可以得到所有操作后的原数组**，即：

```cpp
for(int i = 1; i <= n; i++)
    b[i] += b[i - 1];
```

