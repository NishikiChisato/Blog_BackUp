---
title: 最短路问题
tags: [最短路, 图]
categories: AcWing
---

## 最短路算法概述

这里我们只说算法的实现以及相关的细节问题，不讨论算法的证明

最短路问题分为两种：单源最短路问题和多源汇最短路问题

源点就是起点的意思，汇点就是终点的意思，因此前者是指从一个**确定的起点**到达**其他各个点**的最短路径长度，后者是指从**某个点**到**其他各个点**的最短路径长度

对于单源最短路问题，分为两类：边权均为正和存在负权边，前者用朴素 Dijkstra 算法或者堆优化 Dijkstra 算法，后者用 Bellmen-Ford 算法或者 SPFA 算法

对于多源汇最短路问题，用 Floyd 算法

为了便于讨论，我们约定 $n$ 表示点的个数，$m$ 表示边的个数，并且：

如果满足 $n^2 \sim m$ ，我们定义该图为稠密图，用邻接矩阵来存储（$n=500,\ m=1e5$）

如果满足 $n \sim m$ ，我们定义该图为稀疏图，用邻接表来存储（$n=500,\ m=500$）

​	 

### 朴素 Dijkstra 算法

时间复杂度：$O(n^2)$ ，一般适用于用**邻接矩阵**来存储的**稠密图**，即满足 $n^2\sim m$  

该算法用于**求各个点到 1 号点的最短距离**，下面我们给出该算法的基本思路

假定 $S$ 为当前已经确定最短距离的点，$dist[i]$ 表示**编号**为 $i$ 的点到 1 号点的距离，初始时有：$dist[1]=0,\ dist[i]=INF\ \textit{(这里我们用INF表示正无穷)}$ 

1. 往后，我们**遍历所有点**（执行 $n$ 次），找到不在 $S$ 中的，距离最小的点 $t$ （这个点的 $dist$ 最小）

2. 我们将 $t$ 加入到 $S$ 中

3. 用 $t$ 更新 1 号点到其他所有点的距离

```cpp
const int N = 510;
int n, m;//表示该图中的点数和边数
int g[N][N];//表示点 i 到点 j 的距离为g[i][j]
int d[N];//表示各个点到 1 号点的距离
bool ud[N];//表示各个点是否被使用
int dijkstra()
{
    memset(d, ox3f, sizeof d);
    d[1] = 0;//一定要记得初始化
    for(int i = 1; i <= n; i++)
    {
        int t = -1;
        for(int j = 1; j <= n; j++)
        {
            if(!ud[j] && (j == -1 || d[t] < d[j]))//找到距离1号点最近的点
                t = j;
        }
        
        ud[t] = true;//将这个点加入到S集合中
        
        for(int j = 1; j <= n; j++)//用这个点更新其他点到1号点的距离
        {
            d[j] = min(d[j], d[t] + g[t][j]);//
        }
    }
    if(d[n] == 0x3f3f3f3f) return -1;
    else return d[n];
}
```

不难发现，朴素 Dijkstra 算法全部都是用点数 $n$ 来做循环，并不涉及到边数 $m$ 

由于时间复杂度是 $O(n^2)$ ，因此如果 $n$ 特别大，那么就只能用堆优化 Dijkstra 算法

​	 

### 堆优化 Dijkstra 算法

需要说明的是，堆优化版本并不一定比朴素版本效率更高，二者有相应的应用场景，对应使用即可

在第二个 `for` 循环中，我们是用 `t` 来更新其他所有点到 1 号点的距离，由于 `t` 是不断变化的，并且更新的点都是**`t` 的出边**，因此由于 `t` 会遍历图中的每一个点，因此整体下来这个循环会遍历整个图的所有边，即 $O(m)$ 

我们再看第一个循环，寻找的是所有距离 1 号点距离最近的点，这里的时间复杂度是 $O(n)$ ，我们可以用堆来优化掉这个过程，使得时间复杂度降为 $O(1)$ ，当然，这会使得第二个循环的时间复杂度变为 $O(mlogn)$ ，因为有 $O(logn)$ 是对这个堆进行修改

在实现上，我们选用小根堆，用 STL 的优先队列来实现

关于这个玩意，有一个问题是，它不能删除元素，我们只能往里面添加元素，因此元素最多有 $m$ 个，并在使用之前先进行判断该元素是否已经用过

我们用小根堆，除了维护距离外，还需要维护各个点的编号，并且我们要让**距离为 `first`** ，不然无法进行排序（这一点很重要！！！！）

该算法用于稀疏图，用邻接表来进行存储

```cpp
const int N = 1e6 + 10;
int h[N], e[N], ne[N], w[N], idx;//w[N]表示这条边的权值

int d[N];//存储各个点到1号点的距离
int ud[N];//标记这个点是否使用过
typedef pair<int, int> PII;

void add(int a, int b, int c)
{
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx++;
}

int dijkstra()
{
    memset(h, -1, sizeof h);
    memset(d, 0x3f, sizeof d);//一定要记得初始化
    
    priority_queue<PII, vector<PII>, greater<PII>>heap;//用小根堆，前面是距离，后面是点的编号
    d[1] = 0;
    heap.push({0, 1});
    
    while(!heap.empty())
    {
        auto t = heap.top();
        heap.pop();
        
       int ver = t.second, dis = t.first; 
        
        if(ud[ver]) continue;
        
        ud[ver] = true;//记得修改
        
        for(int i = h[ver]; i != -1; i = ne[i])//ver这个点的出边
        {
            int j = e[i];//e[i]才是节点编号
            if(d[j] > d[ver] + w[i])
            {
                d[j] = d[ver] + w[i];//让j这个点的距离变得更小
                heap.push({j, d[j]});
            }
        }
    }
    
    if(d[n] == ox3f3f3f3f) return -1;
    else return d[n];
}
```

​	 

### Bellmen-Ford 算法

 该算法适用于图中**边权为负**的情况，时间复杂度为 $O(nm)$ 。该算法有一个上位替代算法是 SPFA ，因为后者是前者的一个优化版本，不仅效率快过前者，适用范围也更广，但 Bellmen-Ford 算法也有可以解决一个 SPFA 解决不了的问题，就是我们下面所给的例子

我们先简单描述一下该算法的实现过程

1. 首先第一重循环，循环 $k$ 次，表示**求从编号为 1 的点经过不超过 $k$ 条边所到的点的最短距离**

2. 第二重循环，**遍历所有边**，不断更新每个点到编号为 1 的点的距离，即：

   ```cpp
   d[b] = min(d[b], d[a] + w);//w表示a到b的权重
   ```

这里我们解释一下为什么 $k$ 可以任意取值的情况下时间复杂度仍为 $O(nm)$ 。实际上，由于我们求的是 1 号点到 $n$ 号点的距离，由于整个图当中只有 $n$ 个点，在不考虑负环回路的情况下最多经过 $n+1$ 条边就一定能到达 $n$ 号点（不考虑负环回路是因为如果存在的话是没有最短路径的）。

我们遍历所有边的时候，我们可以用结构体来存储各个边的情况，我们每次**只对边的到达点求最短距离**

由于内层循环每次都会遍历所有边，而外层循环必须保证从 1 号点走出的路径长度，为了保证内层循环不多走，我们需要额外一个数组 `backup` 来保存上一次的结果，用它来更新每个点的距离

```cpp
int n, m, k;

const int N = 510, M = 1e4 + 10;

struct Edge
{
    int a, b, w;
}edge[M];

int d[N], backup[N];

bool Bellmen_Ford()
{
    memset(d, 0x3f, sizeof d);
    d[1] = 0;
    for(int i = 0; i < k; i++)
    {
        memcpy(backup, d, sizeof d);
        for(int i = 1; i <= m; i++)
        {
            int a = edge[i].a, b = edge[i].b, w = edge[i].w;
            d[b] = min(d[b], backup[a] + w);
        }
    }
    if(d[n] > 0x3f3f3f3f / 2) return false;//d[n]可能会减小，但依旧是无穷大，所以这种情况需要返回false
    else return true;
}
```

​	 

### SPFA 算法

只要**图中没有负环就可以用 SPFA** ，当然一般的最短路问题都不会有负环
