---
title: 双指针、位运算、离散化总结
tags: [双指针, 位运算, 离散化]
categories: AcWing
---

## 双指针

这里我们直接给出双指针的代码模板，具体问题具体分析

```cpp
for(int i = 0, j = 0; i < n; i++)
{
    //前置运算
    while(j < i && check(j, i))//当[j,i]直接满足某种条件时，改变左指针
        j++;
    //通常，while循环的判断条件为不满足题意的条件
    //后面对结果进行记录
}
```

​	 

## 位运算

求 $n$ 的第 $k$ 位数字（ $k$ 从 1 开始）

```cpp
n >> k & 1
```

返回 $n$ 的最后一位 1 

```cpp
lowbit(n) = n & -n
```

一般后者可以求出一个二进制数当中 1 的个数

```cpp
int ans = 0, t = 0;
cin >> t;
while(t)
{
    t -= lowbit(t);
    ans++;
}
cout << ans << endl;
```

## 离散化

离散化的操作是将一些**大的**、**离散的**的数据映射为一些**小的**、**不离散**的数据

具体的，假如说我有 $10^5$ 个数据，但每个数据的大小最大可以到 $10^9$ （我们暂且不考虑负数的情况）

如果我需要将这些数据作为数组下标，开 $10^9$ 大小的数组空间是不显示的，这里我们就需要将数值做一些映射

离散化的前提是**数值有序**且**无重复**，对于这两点的实现可以用以下两行代码

```cpp
//vector<int>alls
alls.erase(unique(alls.begin(), alls.end()), alls.end());
sort(alls.begin(), alls.end());
```

这里我们给出 `unique` 函数的实现

```cpp
vector<int>::iterator unique(vector<Int>& alls)
{
    int j = 0;
    for(int i = 0; i < alls.size(); i++)
        if(i == 0 || alls[i] != alls[i - 1])//第一个数进行单独判断，除此之外其余的数，如果重复，必然是重复前一个数
            alls[j++] = alls[i];
    return alls.begin() + j;
}
```

关于离散化映射关系的寻找，其实非常的简单，我们将那**没有重复的 $10^5$ 个数**放在一个对应大小的数组内（我们是将原数组的索引放入一个新的数组），然后我们通过**新数组的索引**来替换掉**原本数组的索引**，这样便实现了映射

在具体实现上，我们令 `alls` 数组来存放所有待离散化的数据，我们考虑用每个数据的索引来替换掉原本的数

由于 `alls` 数组是有序的，因此我们可以使用二分查找来找到某个数据的索引（即找到第一个大于等于 $x$ 的数的索引）

```cpp
int find(int x)
{
    int l = 0, r = alls.size();
    while(l < r)
    {
        int mid = l + r >> 1;
        if(alls[mid] >= x) r = mid;
        else l + mid + 1;
    }
    return l;//返回值可以根据情况加上一个不同的常数
}
```

实际上，离散化的本质是构建一个映射关系将一些离散的数据对应到一些不离散的数据，在这个过程的实现当中，我们需要让映射后的数据与原数据具有一样的性质，这里的性质便是单调性

也就是说，如果原数据不具有单调性的话，我们是无法进行离散化的

由于原数据具有单调性，因此我们在映射的时候便可以使用二分，找到第一个大于等于原始数据的索引

以上，便是离散化的整个过程以及理解