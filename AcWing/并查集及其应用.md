---
title: 并查集及其应用
tags: [并查集, 图]
categories: AcWing
---

## 定义

并查集是一个用于快速判断两个点是否处于同一个集合的数据结构，当然它还有一个应用是将两个集合合并成一个新的集合

并查集可以看成一个树型结构，我们通过数组 `p[N]` 来模拟这棵树

我们用数组索引（从 1 开始）表示节点编号，数组元素值表示当前节点的父节点，对于一棵树的根节点，我们有 $p[x]=x$ 

初始时，我们让每个节点都是根节点，因此初始化为：

```cpp
for(int i = 1; i <= n; i++)
    p[i] = i;
```

由于每个数组索引对应的值都表示当前节点的父节点，因此我们用**根节点来表示整个集合**，那么只要找到某个节点的根节点，就能判断当前节点属于哪个集合了

我们定义 `int find(int x)` 函数会返回当前节点的根节点，有：

```cpp
int find(int x)
{
    while(x != p[x]) x = p[x];
    return x;
}
```

当然，这只是朴素并查集的写法，这么写的时间复杂度跟整棵树的高度有关，我们通常会写路径压缩的版本，也就是让每个节点的父节点都为根节点，即：

```cpp
int find(int x)
{
    if(x != p[x]) p[x] = find(p[x]);
    return p[x];
}
```

如果我们要将两个集合合并，只需要找出两个集合的根节点，并让一个根节点的父节点等于另一个根节点就行（原先是等于它本身），即：

```cpp
int px = find(x), py = find(y);
p[px] = py;
```

一般在并查集的应用里面，我们都会利用并查集来维护一些额外的信息

## 题目

### [836. 合并集合 - AcWing题库](https://www.acwing.com/problem/content/838/) 

模板题，没什么好说的

```cpp
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int p[N];

int find(int x)
{
    if(x != p[x]) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    int n, m;
    cin >> n >> m;
    
    for(int i = 1; i <= n; i++)
        p[i] = i;
    
    while(m--)
    {
        int a, b;
        char op[2];
        scanf("%s", op);
        if(op[0] == 'M')
        {
            scanf("%d%d", &a, &b);
            p[find(a)] = find(b);
        }
        else 
        {
            scanf("%d%d", &a, &b);
            if(find(a) == find(b)) cout << "Yes" << endl;
            else cout << "No" << endl;
        }
    }
    return 0;
}
```



### [240. 食物链 - AcWing题库](https://www.acwing.com/problem/content/242/)

我们从 $A$ 吃 $B$ ，$B$ 吃 $C$ ，$C$ 吃 $A$ 这个关系入手，不难发现，三者之间的关系具有**传递性**，即这个集合内的元素构成偏序关系

我们可以用一组**向量**来描述这个关系，我们定义向量 $\overrightarrow{AB}$ 表示 $A$ 吃 $B$ ，同理，$B$ 吃 $C$ 有：$\overrightarrow{BC}$ ，那么 $C$ 吃 $A$ 就有：$\overrightarrow{CA}=\overrightarrow{AB}+\overrightarrow{BC}$ 

如果我们给每个向量赋予一个非负数的话，由于非负数的加法会越加越大，因此我们通过**余数**来判断**某个数字表示的是哪种关系**

也就是说，所有带有**关系传递性质的定义，都可以通过上述的过程来描述**

另一方面，由于这里涉及到判断两个动物是否属于同类，也就是去询问两个变量是否处于同一个集合内，不难想到要用并查集

再者，对于某个确定编号的动物而言，其余所有动物跟它的关系不外乎三种：跟它同种类型、吃它、被它吃

在这里，对其余所有节点描述关系过于复杂，我们仅描述当前节点与其父节点的关系，其余的所有节点之间的关系都可以间接推出

我们对 $x$ 与 $p[x]$ 的定义如下

* 若 $x-p[x]$ 余数为 0 ，表示 $x$  与 $p[x]$ 属于同一类
* 若 $x-p[x]$ 的余数为 1 ，表示 $x$ 吃 $p[x]$ 
* 若 $x-p[x]$ 的余数为 2 ，表示 $x$ 被 $p[x]$ 吃

关于余数的记录，我们另外需要一个数组 `d[N]` ，表示当前节点与父节点的关系

需要特别说明的是，我们所定义的「关系」，是满足**加法原理**的，可以直接相加，最终取模就行

剩下的，就是判断什么情况会导致最终结果 `res` 变化了

```cpp
#include <iostream>
using namespace std;

const int N = 5e4 + 10;

int p[N], d[N];

int find(int x)
{
    if(x != p[x])
    {
        int t = find(p[x]);
        d[x] = d[x] + d[p[x]];
        p[x] = t;
    }
    return p[x];
}

int main()
{
    cin.tie(0);
    ios::sync_with_stdio(false);
    int n, m, res = 0;
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
    {
        p[i] = i;
        d[i] = 0;
    }
    while(m--)
    {
        int t, x, y;
        cin >> t >> x >> y;
        if(x > n || y > n) res++;
        else
        {
            if(t == 1)
            {
                int px = find(x), py = find(y);
                if(px != py)
                {
                    p[px] = py;
                    d[px] = d[y] - d[x];
                }
                else if(px == py && (d[x] - d[y]) % 3 != 0) res++;
            }
            else if(t == 2)
            {
                int px = find(x), py = find(y);
                if(px == py && (d[x] - d[y] - 1) % 3 != 0) res++;//必须要是dx比dy多一，写成(dx-dy)%3 == 1 是错误的
                else if(px != py)
                {
                    p[px] = py;
                    d[px] = d[y] - d[x] + 1;
                }
            }
        }
    }
    cout << res << endl;
    return 0;
}
```

