---
title: 字符串哈希
tags: [字符串, 哈希]
categories: AcWing
---

## 普通哈希

对于普通哈希函数的设计，我只需要让 $x$ 模一个质数并保证它是一个正数即可

```cpp
const int N = 1e5 + 3;//大于1e5的第一个质数
int hash(int x)
{
    int k = (x % N + N) % N;//括号里面加一个N是为了保证结果为正数
    return k;
}
```

​	 

## 字符串哈希

对于字符串的哈希，我们显然不能这么做

我们假定字符串中的每个字符都唯一对应一个**不为零**的整数（我们可以直接用 ASCII 码代替），然后我们便可以根据每个字符所对应的数写出一个 $P$ 进制的数，最后我们将这个 $P$ 进制转化为十进制即可

这里的哈希是根据字符串的前缀写出来的，也只能根据字符串的前缀来写。如果我们需要求任意一段的哈希值的话，可以通过前缀和来推

需要注意的是：

* 我们一般会取 $P$ 为 $131$ 或 $13331$ 
* 由于字符串一般都是上万数量级的，因此最终的值会非常大，我们需要将结果对 $Q$ 取模，$Q$ 的经验值为 $2^{64}$ 。这里有一个取巧的办法是，直接将 $Q$ 声明为 `unsigned long long` ，这样溢出之后会自动取模

需要说明的是，我们默认字符串哈希是不会发生碰撞的

如果我们需要求闭区间 $[L,\ R]$ 的哈希值，有

对于字符串 $1\sim R$ ，其最低位权重为 0 ，最高位权重为 $R-1$ ；对于字符串 $1\sim (L-1)$ ，其最低为权重为 0 ，最高位权重为 $(L-1)-1$ ，二者之间最高位权重之间的差值为 $R-L+1$ ，我们需要将短的字符串向左以为，使得其与较长的字符串的各个位相对应，即后者每一位都需要乘上 $P^{R-L+1}$ 

因此闭区间 $[L,\ R]$ 的哈希值为 $h[R]-h[L-1]*P^{R-l+1}$ 

在这里，我们可以提前处理出来 $P$ 的前缀和数组

```cpp
const int N = 1e5 + 10, P = 131;
int h[N], p[N];

for(int i = 1; i <= s.length(); i++)
{
    h[i] = h[i - 1] * p + s[i - 1];
    p[i] = p[i - 1] * P;
}

//求[L, R]区间的哈希值
int get(int L, int R)
{
    return h[R] - h[L - 1] * p[R - L + 1];
}
```

