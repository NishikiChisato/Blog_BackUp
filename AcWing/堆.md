---
title: 堆
tags: [堆, 优先队列]
categories: AcWing
---

## 堆

我们用一个数组 `h[N]` 来存储堆，变量 `size` 表示当前堆当中的元素个数

我们定义两种操作：

* `void up(int u)` 表示将下标为 `u` 的元素向上升，

* `void down(int u)` 表示将下标为 `u` 的元素向下沉

以小根堆为例，我们需要保证在三个元素当中，顶部元素是最小的，因此我们只需要找出三者当中的最小值并将其放在顶部即可

```cpp
int h[N], sz;

void down(int u)
{
    int t = u;//t用来记录最小值的下标
    if(2 * u <= sz && h[2 * u] < h[t]) t = 2 * u;//左孩子较小，对 t 赋值
    if(2 * u + 1 <= sz && h[2 * u + 1] < h[t]) t = 2 * u + 1;//同理
    if(t != u)
    {
        swap(t, u);
        down(t);//这里是对t进行调整
    }
}

void up(int u)
{
    while(u / 2 > 0 && h[u / 2] < h[u])
    {
        swap(u / 2, u);
        u /= 2;
    }
}
```

在无法确定使用 `up` 还是 `down` 时，我们二者都写，反正也只会调用一个

下面我们给出一个更一般的堆模型

```cpp
int h[N], ph[N], hp[N], sz;//ph表示第k个插入的点的下标是什么，hp表示下标为k的点是第几次插入的，二者下标的意义并不相同

void head_swap(int a, int b)//交换下标为a和b的两个数
{
    swap(ph[hp[a]], ph[hp[b]]);//我们需要先找到下标为a的点是第几次插入的，这一点对于b也是同理
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if(2 * u <= sz && h[2 * u] < h[t]) t = 2 * u;
    if(2 * u + 1 <= sz && h[2 * u + 1] < h[t]) t = 2 * u + 1;
    if(t != u)
    {
        head_swap(t, u);
        down(t);
    }
}

void up(int u)
{
    while(u / 2 && h[u] < h[u / 2])
    {
        head_swap(u, u / 2);
        u = u / 2;
    }
}
```

