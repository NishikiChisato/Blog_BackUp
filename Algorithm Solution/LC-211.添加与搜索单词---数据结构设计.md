---
title: LC 211.添加与搜索单词 - 数据结构设计
tags: [Trie, 数据结构设计]
categories: Algorithm Solution
---

#### [211. 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

难度中等461收藏分享切换为英文接收动态反馈

请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。

实现词典类 `WordDictionary` ：

- `WordDictionary()` 初始化词典对象
- `void addWord(word)` 将 `word` 添加到数据结构中，之后可以对它进行匹配
- `bool search(word)` 如果数据结构中存在字符串与 `word` 匹配，则返回 `true` ；否则，返回 `false` 。`word` 中可能包含一些 `'.'` ，每个 `.` 都可以表示任何一个字母。

```
输入：
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
输出：
[null,null,null,null,false,true,true,true]

解释：
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // 返回 False
wordDictionary.search("bad"); // 返回 True
wordDictionary.search(".ad"); // 返回 True
wordDictionary.search("b.."); // 返回 True
```



#### 模拟

这是一道简单的 Trie 练习题，我们唯一需要注意的是，在出现 `.` 的时候，需要将该节点的所有孩子全部遍历一次，反之我们只需要遍历一个孩子

```cpp
class WordDictionary 
{
private:
	bool isEnd;
	vector<WordDictionary*>next;

	bool dfs(WordDictionary* root, int inx, string word)
	{
		if (inx == word.length())
			return root->isEnd;
		char c = word[inx];
		if (c == '.')
		{
			for (int i = 0; i < root->next.size(); i++)
				if (root->next[i] != nullptr && dfs(root->next[i], inx + 1, word))
					return true;
			return false;
		}
		else
		{
			if (root->next[c - 'a'] == nullptr)
				return false;
			return dfs(root->next[c - 'a'], inx + 1, word);
		}
	}
public:
	WordDictionary() 
	{
		isEnd = false;
		next.assign(26, nullptr);
	}

	void addWord(string word) 
	{
		WordDictionary* node = this;
		for (char c : word)
		{
			if (node->next[c - 'a'] == nullptr)
				node->next[c - 'a'] = new WordDictionary();
			node = node->next[c - 'a'];
		}
		node->isEnd = true;
		return;
	}

	bool search(string word) 
	{
		return dfs(this, 0, word);
	}
};
```

