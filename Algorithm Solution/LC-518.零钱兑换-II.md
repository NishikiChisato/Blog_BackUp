---
title: LC 518.零钱兑换 II
tags: [动态规划, 背包]
categories: Algorithm Solution
---

#### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-2/)

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```



#### DP 数组

这个就是我们之前做过的完全背包的问题，只要把完全背包的原理理解了，这种题就是秒杀

题目要我们返回所有的可能，我们知道 `dp[j]` 的状态只会从 `dp[j]` 和 `dp[j-val]` 当中转移过来，我们直接把二者相加即可

这道题唯一要注意的就是 Base Case 

当我们考虑前 0 个元素时，若要凑出 0 ，总共会有 1 种可能性

考虑前 0 个，相当于什么都不选，这时我当然可以凑出 0 啊，所以是 1 种

往后的，这道题就没有什么思维难度了

```cpp
class Solution {
public:
	int change(int amount, vector<int>& coins)
	{
		int n = coins.size();
		vector<int>dp(amount + 1, 0);
        dp[0] = 1;
		for (int i = 1; i <= n; i++)
		{
			int val = coins[i - 1];
			for (int j = val; j <= amount; j++)
			{
				dp[j] = dp[j] + dp[j - val];
			}
		}
		return dp[amount];
	}
};
```

时间复杂度：$O(n^2)$ 

空间复杂度：$O(n)$ 