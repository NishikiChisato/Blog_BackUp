---
title: LC 687.最长同值路径
tags: 二叉树
categories: Algorithm Solution
---

#### [687. 最长同值路径](https://leetcode.cn/problems/longest-univalue-path/)

给定一个二叉树的 `root` ，返回 *最长的路径的长度* ，这个路径中的 *每个节点具有相同值* 。 这条路径可以经过也可以不经过根节点。

**两个节点之间的路径长度** 由它们之间的边数表示。

```
输入：root = [5,4,5,1,1,5]
输出：2
```



#### DFS

对于二叉树中任意一个节点 `root` ，我们想要找到包含它的最长同值路径，我们就必须要知道「`root->left` 与 `root->right` 其本身为**起点**」的路径长度 `ans` ，并将这两个 `ans` 相加

进一步，我们需要知道这两个 `ans` 的**较大值**才能确定**以该节点为起点**的路径长度

根据这一点，我们可以很容易确定这里需要用**后序遍历**

然后我们再维护一个变量 `cur` ，用来记录包含此节点 `root` 的最长路径的值

如此这般，取最大的 `cur` 作为最后输出即可

```cpp
class Solution {
public:
	int curmax = 0;
	int traveral(TreeNode* root)
	{
		if (root == nullptr)
			return 0;
		int left = traveral(root->left);
		int right = traveral(root->right);
		int ans = 0, cur = 0;     //ans 表示其左右孩子以它们本身为起点的最长路径
		                          //cur 表示包含当前节点的最长路径
        						  //ans 与 cur 必须初始化为 0 ，因为我们是对这个节点进行讨论
		if (root->left != nullptr && root->left->val == root->val)
		{
			ans = left + 1;//因为相同的缘故，所以要加 1
			cur += ans;
		}
		if (root->right != nullptr && root->right->val == root->val)
		{
			ans = max(ans, right + 1);//对 ans 取较大值，后面将其返回给上一层
			cur += right + 1;
		}
		curmax = curmax > cur ? curmax : cur;//取 cur 最大值
		return ans;
	}

	int longestUnivaluePath(TreeNode* root)
	{
		traveral(root);
		return curmax;
	}
};
```

时间复杂度：$O(n)$ ，仅仅是遍历这棵二叉树

空间复杂度：$O(1)$ ，申请了常数量级的空间