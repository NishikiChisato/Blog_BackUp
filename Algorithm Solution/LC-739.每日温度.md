---
title: LC 739.每日温度
tags: [单调栈, 数组]
categories: Algorithm Solution
---

#### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

​	 

#### 单调栈

这道题再次帮我强化了一遍对单调栈的理解

显然，这就是一个单调栈的问题，唯一需要注意的是栈中元素是严格大于还是大于等于

我们栈中保存的元素是**当前元素的最大值**，当我们遍历到 `nums[i]` 时，我们需要需要检查当前栈中是否有**严格大于** `nums[i]` 的元素，对于不满足条件的我们需要将其弹出栈

也就是说，如果我们期望找到一个**严格大于** `nums[i]` 的元素，那么我们需要将**小于等于**的元素全部弹出栈

同理，如果我们期望找到一个**大于等于** `nums[i]` 的元素，那么我们需要将**严格小于**的元素全部弹出栈

其他情况同理

对于单调栈的理解关键在于这一句话，理解了就不难

完整代码如下

```cpp
class Solution {
public:
	vector<int> dailyTemperatures(vector<int>& temperatures)
	{
		stack<int>st;
		int n = temperatures.size();
		vector<int>ret(n, 0);
		for (int i = n - 1; i >= 0; i--)
		{
			while (!st.empty() && temperatures[st.top()] <= temperatures[i])
				st.pop();
			ret[i] = st.empty() ? 0 : st.top() - i;
			st.push(i);
		}
		return ret;
	}
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(n)$ 