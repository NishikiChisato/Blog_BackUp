---
title: LC 870.优势洗牌
tags: [数组, 双指针, 贪心]
categories: Algorithm Solution
---

#### [870. 优势洗牌](https://leetcode.cn/problems/advantage-shuffle/)

给定两个大小相等的数组 `nums1` 和 `nums2`，`nums1` 相对于 `nums2` 的*优势*可以用满足 `nums1[i] > nums2[i]` 的索引 `i` 的数目来描述。

返回 nums1 的**任意**排列，使其相对于 `nums2` 的优势最大化。

示例 1：
```
输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]
输出：[2,11,7,15]
```
示例 2：
```
输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]
输出：[24,32,8,12]
```

提示：

* 1 <= nums1.length <= 105
* nums2.length == nums1.length
* 0 <= nums1[i], nums2[i] <= 109

​	 

#### 贪心 + 双指针

这实际就是田忌赛马的问题

A 和 B 两个人赛马，A 想要赢的话只能做如下决策

* A 的下等马与 B 的上等马比
* A 的中等马与 B 的下等马比
* A 的上等马与 B 的中等马比

一句话概括就是，赢不了就摆烂，换掉对面最强的一个；赢得了就无所谓，但一定不能摆烂

在具体的代码实现上，我们新建一个数组 `idx` 用来对 `nums2` 进行排序后的数的下标进行记录。之后，我们维护两个指针指向 `idx` ，一个表示当前较小值，另一个为当前最大值

我们每次选取 `nums1` 当中的较小值进行比较，如果能比 `nums2` 当中的当前较小值大，那么我们就将 `nums1` 当中的这个数放在 `nums2` 当中对应的位置；如果比不过，则放在 `nums2` 当前最大值对应的位置

```cpp
class Solution {
public:
    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) 
    {
        int n = nums1.size();
        vector<int>ans(n, 0), idx(n, 0);
        sort(nums1.begin(), nums1.end());
        for(int i = 0; i < n; i++)
            idx[i] = i;
        sort(idx.begin(), idx.end(), [&](int i, int j){ return nums2[i] < nums2[j]; });
        int belo = 0, high = n - 1;
        for(int x : nums1)
        {
            ans[ x > nums2[idx[belo]] ? idx[belo++] : idx[high--]] = x;
        }
        return ans;
    }
};
```

时间复杂度：$O(nlogn)$ 

空间复杂度：$O(n)$
