---
title: LC 899. 有序队列
tags: [字符串, 残留]
categories: Algorithm Solution
---

#### [899. 有序队列](https://leetcode.cn/problems/orderly-queue/)

给定一个字符串 `s` 和一个整数 `k` 。你可以从 `s` 的前 `k` 个字母中选择一个，并把它加到字符串的末尾。

返回 *在应用上述步骤的任意数量的移动后，字典上最小的字符串* 。

```
输入：s = "cba", k = 1
输出："acb"
解释：
在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。
在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。
```



#### 暴力循环

这个题乍一看觉得无从下手，实际上简单的要死。

我们分开来看，先看 `k = 1` 的情况

这时，我们每次都会把第一个字符放到字符串的最后一位，这会生成 `n` 个字符串，我们只需要取这 `n` 个字符串中最小的那个就行。就是最简单的打擂台。这个地方的时间复杂度为 *O( $n^2$ )* ，因为需要遍历一遍这个字符串的同时，还需要进行插入，因此是 $n^2$ 。

然后，当 `k = 2` 时，**我们可以从前面两个中选择一个放到最后一位**，那么只需要我们每次都选择两个中较大的那个，把它放到最后去，是不是相当于把这个字符串整体进行一次排序？

当然 `k > 2` 的情况同理，这时的时间复杂度为 *O( $nlogn$ )* 。

代码如下：

```cpp
class Solution {
public:
	string orderlyQueue(string s, int k)
	{
		if (k == 1)
		{
			string ret(s);
			for (int i = 0; i < s.length(); i++)
			{
				s.insert(s.end(), s[0]);
				s.erase(s.begin());
				if (s < ret)
					ret = s;
			}
			return ret;
		}
		else
		{
			sort(s.begin(), s.end());
			return s;
		}
	}
};
```

时间复杂度：*O( $n^2$ )*

空间复杂度：*O( $n$ )* 

这个题可以用最小表示法来解，但是那个玩意我看不懂。。。。。过一段时间再来看看把。
