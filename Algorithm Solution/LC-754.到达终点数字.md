---
title: LC 754.到达终点数字
tags: [数学]
categories: Algorithm Solution
---

#### [754. 到达终点数字](https://leetcode.cn/problems/reach-a-number/)

在一根无限长的数轴上，你站在`0`的位置。终点在`target`的位置。

你可以做一些数量的移动 `numMoves` :

- 每次你可以选择向左或向右移动。
- 第 `i` 次移动（从  `i == 1` 开始，到 `i == numMoves` ），在选择的方向上走 `i` 步。

给定整数 `target` ，返回 *到达目标所需的 **最小** 移动次数(即最小 `numMoves` )* 。

 

**示例 1:**

```
输入: target = 2
输出: 3
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 -1 。
第三次移动，从 -1 到 2 。
```

**示例 2:**

```
输入: target = 3
输出: 2
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 3 。
```

 

**提示:**

- `-109 <= target <= 109`
- `target != 0`

​	 

#### 数学

我们设 $rage$ 表示当前走到的范围，只要 $rage < target$ ，那么我们就需要继续往后走，因为还没有到达终点，也就是说，我们只考虑当 $rage\ge target$ 的情况

显然，当 $rage=target$ 时，我们直接返回最后一步的**距离**，**距离就是答案**（因为步数是从 1 开始的，因此这个可以帮我们进行计数）

当 $rage>target$ 时，分为两种情况

* 若 $rage$ 为偶数，例如 $target=8,\ rage=10$ ，这时我们只需要将第一步反向（比如 $(-1)+2+3+4=8$），也就是我们需要多走一步才能退出循环
* 若 $rage$ 为奇数，又可以分为两种情况
  * 若 $rage-target=1$ ，我们可以先向右走再向左走，也就是多走一步才能退出循环
  * 若 $rage-target>1$ ，我们总体往右走一步（先向左后向右），这可以转化成偶数的情况，也就是需要进行多一次循环才能变为偶数的情况

综上，我们需要进行循环的条件为 $rage<target$ 或 $rage-target$ 为奇数

完整代码如下

```cpp
class Solution {
public:
    int reachNumber(int target) 
    {
        target = abs(target);
        int step = 0, rage = 0;
        while(rage < target  || (rage - target) % 2 == 1)
        {
            rage += ++step;
        }
        return step;
    }
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(1)$ 