---
title: LC 907.子数组的最小值之和
tags: [单调栈, 动态规划, 数学]
categories: Algorithm Solution
---

#### [907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/)

给定一个整数数组 `arr`，找到 `min(b)` 的总和，其中 `b` 的范围为 `arr` 的每个（连续）子数组。

由于答案可能很大，因此 **返回答案模 `10^9 + 7`** 。

```
输入：arr = [3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
```

​	 

#### 单调栈 + 数学原理

题目要我们求所有子数组的最小值之和。我们肯定不可能把所有子数组列出来，那样肯定超时

我们应当考虑单个元素对于最终答案的贡献如何，即对于任意元素 `a[i]` ，有多少个子数组是以它为最小值的，那么 `a[i]` 对于最终答案的贡献就是子数组的个数乘以 `a[i]` 

具体地，我们只需要找出 `i` 左边第一个比它小的元素和右边第一个比它小的元素就行

具体地，我们维护两个数组 `l` 和 `r` ，其中 `l[i] = a` 表示 `i` 左边第一个比它小的数的下标（如果没有则为 0 ），`r[i] = a` 表示 `i` 右边第一个比它小的数的下标（如果没有则为 n ）

关于 `l` 和 `r` 的处理，完全就是单调栈的问题，前者从前往后遍历，后者从后往前遍历即可

那么 `i` 左边的数有 $(i-l[i])$ 个，右边的数有 $(r[i]-i)$ 个，根据乘法原理可得，位于区间 `[l[i], r[i]]` 的所有子数组的个数为 $(i-l[i])\cdot (r[i]-i)$ 

这里唯一需要注意的问题是，对于区间左右边界的确定，到底是**严格小于**还是**小于等于**

* 如果两边都是严格小于的话，那么原本可以加入区间的元素就会被排除在外，不可取
* 如果两倍都是小于等于的话，区间内会有多个重复元素，会造成多次计算，不可取
* 因此应当一边严格小于，另一半小于等于

完整代码如下：

```cpp
class Solution {
public:
	int mod = 1e9 + 7;

	int sumSubarrayMins(vector<int>& arr)
	{
		int n = arr.size();
		vector<int>l(n, -1), r(n, n);
		deque<int>st;
		for (int i = 0; i < n; i++)
		{
			while (!st.empty() && arr[i] < arr[st.back()])
				st.pop_back();
			l[i] = st.empty() ? -1 : st.back();
			st.push_back(i);
		}
		st.clear();
		for (int i = n - 1; i >= 0; i--)
		{
			while (!st.empty() && arr[i] <= arr[st.back()])
				st.pop_back();
			r[i] = st.empty() ? n : st.back();
			st.push_back(i);
		}
		long long sum = 0;
		for (int i = 0; i < n; i++)
		{
			sum += (long long)(i - l[i]) % mod * (long long)(r[i] - i) % mod * arr[i] % mod;
			sum %= mod;
		}
		return sum;
	}
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(n)$ 

​	 

#### 单调栈 + DP

我们定义 `dp[i]` 为所有以下标 `i` 为结尾的子数组的最小值之和

根据我们前面的分析，我们需要找出 `arr[i]` 前面的一个**严格小于**的它元素，设其下标为 `index` ，则：

若 `index` 存在，那么 $dp[i]=dp[index]+(i-index)*arr[i]$ 

若 `index` 不存在，那么 $dp[i]=arr[i]*(i+1)$ 

关于找出第一个严格小于的元素，我们可以采取单调栈

在进入循环的时候，只需要**让栈中的元素全部满足「严格小于」**即可。因此，我们需要让栈中**大于等于** `arr[i]` 的元素全部弹出栈（实际上所有的单调栈弹出部分都可以这么思考）

完整代码如下：

```cpp
class Solution {
public:
	int mod = 1e9 + 7;

	int sumSubarrayMins(vector<int>& arr)
	{
		int n = arr.size();
		vector<int>dp(n, 0);
		deque<int>st;
		vector<int>index(n, 0);
		for (int i = 0; i < n; i++)
		{
			while (!st.empty() && arr[i] <= arr[st.back()])//由于需要找出比arr[i]严格小的元素，因此栈中所有大于等于的元素全部需要弹出
				st.pop_back();
			index[i] = st.empty() ? -1 : st.back();
			st.push_back(i);
		}
        int ans = 0;
		for (int i = 0; i < n; i++)
		{
			dp[i] = index[i] == -1 ? arr[i] * (i + 1) : dp[index[i]] + (i - index[i]) * arr[i];
			dp[i] %= mod;
            ans = (ans + dp[i]) % mod;
		}
		return ans;
	}
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(n)$ 