---
title: LC 42.接雨水（单调栈的究极理解题）
tags: [单调栈, 总结, 残留]
categories: Algorithm Solution
---

#### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

难度困难3868

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

 

**提示：**

- `n == height.length`
- `1 <= n <= 2 * 104`
- `0 <= height[i] <= 105`

​	 

#### 单调栈

我们说，栈具有先进后出的特性

这句话实际是在说，我们可以通过栈来**「找到当前元素的前一个元素」**，做法是将栈顶元素弹出

同理，队列具有先进先出的特性

这句话实际是在说，我们可以通过队列来**「找到当前元素的后一个元素」**，做法是将队头元素弹出

那么什么叫「单调栈」？

我们给出一个无序的序列 `nums` ，以当前元素 `nums[i]` 为终点的单调栈表示为**「找出当前元素前面所有满足单调性的元素」**，对于这些元素，我们可以**「依次找到某个元素的前一个元素」**，这是单调栈的核心

如果我们需要知道当前栈顶元素的前一个元素，那么我们可以将栈顶元素弹出，之后的栈顶元素便是原先栈顶元素的前一个元素

结合我们之前的理解

* [LC 739.每日温度 ](https://nishikichisato.github.io/2022/10/02/Algorithm Solution/LC-739.每日温度/) 栈中元素表示当前最大元素，如果我们期望在栈中找到一个**严格大于** `nums[i]` 的元素，那么我们需要将所有**小于等于**的元素弹出栈中，其实质是维护了一个**严格递增的栈**
* [LC 581.最短无序连续子数组 ](https://nishikichisato.github.io/2022/10/06/Algorithm Solution/LC-581.最短无序连续子数组/) 对于**严格递增**的单调栈，如果我将一个部分有序的序列全部压入栈中，那么它会自动将不符合**严格递增**属性的元素全部弹出

那么这道题也就没有问题了

假设我们遍历到 `height[i]` 元素，如果我期望它作为一个边界，那么它只能是作为右边界（如果是左边界的话，尚且还没有遍历到后面的元素）

那么，如果我们希望它能够构成容器的话，必须满足它**前一个元素 `height[mid]` 需要严格小于它**

对于 `height[mid]` 的前一个元素 `height[left]` 又需要**严格大于它**

也就是说，在这里我们需要找**一个元素的前一个严格小于的元素**，很明显需要用单调栈

特别地，当我们遍历到 `height[i]` 时，栈顶元素就是 `height[mid]` ，但其前一个元素 `height[left]` 的获取需要将目前的栈顶元素弹出

需要特别注意的是，我们并不需要将 `height[left]` 给弹出，因为**我们不需要找它的前一个元素**

完整代码如下：

```cpp
class Solution {
public:
    int trap(vector<int>& height) 
    {
        stack<int>stk;
        int ans = 0;
        for(int i = 0; i < height.size(); i++)
        {
            while(!stk.empty() && height[stk.top()] < height[i])
            {
                int mid = stk.top();
                stk.pop();
                if(stk.empty()) break;
                int left = stk.top();
                int x = min(height[i], height[left]);
                ans += (x - height[mid]) * (i - left - 1);
            }
            stk.push(i);
        }
        return ans;
    }
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(1)$ 

实际上这道题可以将空间复杂度优化到 $O(1)$ ，但这个我们以后再搞，感觉不是很容易

​	 

#### 另一种理解

这道题的单调栈的写法不同于我们以往所写的

以前的写法是，先对整个栈进行处理，确保其单调，进而再对数组赋值

这道题的单调栈写法可以理解为：

我**总是**将所有元素加入到栈中，当我需要的时候我便将元素弹出

这里有两个问题：

* 什么时候「需要」，这里对应 `while` 循环的部分，只要栈顶元素小于当前元素，我们将进入循环部分，也就是「需要」
* 为什么「弹出」，这里对应我们需要找出当前元素的前一个元素

那么这里有一个问题是，我们是如何维护这个栈的「单调性」的？

我们期望构造一个单调递减的栈，这才能实现我们的想法

实际上，这里维护的压根就称不上是「单调栈」，我们只是借用栈可以「找到前一个元素」以及可以「将元素弹出」的这两个属性来解决问题而已，本质上跟单调性无关
