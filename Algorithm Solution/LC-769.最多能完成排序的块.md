---
title: LC 769.最多能完成排序的块
tags: [数组, 模拟]
categories: Algorithm Solution
---

#### [769. 最多能完成排序的块](https://leetcode.cn/problems/max-chunks-to-make-sorted/)



给定一个长度为 `n` 的整数数组 `arr` ，它表示在 `[0, n - 1]` 范围内的整数的排列。

我们将 `arr` 分割成若干 **块** (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。

返回数组能分成的最多块数量。

 

**示例 1:**

```
输入: arr = [4,3,2,1,0]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。
```

**示例 2:**

```
输入: arr = [1,0,2,3,4]
输出: 4
解释:
我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。
```

 

**提示:**

- `n == arr.length`
- `1 <= n <= 10`
- `0 <= arr[i] < n`
- `arr` 中每个元素都 **不同**

​	 

#### 模拟

这种题还挺常见的，差不多都有规律

数组 `arr` 有 $N$ 个数，这 $N$ 个数**互不相同**，范围为 $[0,N-1]$ ，那么对于任意一个数 `nums[i]` ，它**所在的下标为 `nums[i]`** ，并且将所有数归位之后，**整个数组有序**

也就是说，只要满足有 $N$ 个数，这 $N$ 个数**互不相同**，**给定一个范围**，那么**每个数所在的下标都是确定的**

对于本题，每一个数都有一个确定的位置，只要还没有遍历到这个位置，那么就说明当前区域内所有的数都属于同一个块

具体地，我们定义 `mx` 表示当前的最大值，只要 `i` 没有遍历到下标 `mx` ，那么说明当前所在的区域全部都是一个块

当 `i == mx` 时，直接令结果加一即可

完整代码如下：

```cpp
class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) 
    {
        int mx = 0, cnt = 0;
        for(int i = 0; i < arr.size(); i++)
        {
            mx = max(mx, arr[i]);
            if(mx == i) cnt++;
        }
        return cnt;
    }
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(1)$ 