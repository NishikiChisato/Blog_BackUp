---
title: LC 560.和为 K 的子数组
tags: [前缀和, 哈希表, 数组]
categories: Algorithm Solution
---

#### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的连续子数组的个数* 。

 

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

 

**提示：**

- `1 <= nums.length <= 2 * 104`
- `-1000 <= nums[i] <= 1000`
- `-107 <= k <= 107`

​	 

#### 前缀和暴力检索

我们看到，求数组当中和为 `k` 的子数组，我们应当马上想到前缀和

我们定义 `preSum` 数组表示**前 `i` 个数的和**，有：
$$
preSum[i]=preSum[i-1]+nums[i]
$$
初始时，我们需要让 `preSum` 中下标为 0 的数置零

之后我们在前缀和数组当中不断的检索两个数组边界来确定数组范围，进而不断计数

不过该代码会超时

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) 
    {
        int n = nums.size();
        vector<int>preSum(n + 1, 0);
        for(int i = 0; i < n; i++)
            preSum[i + 1] = preSum[i] + nums[i];
        int ans = 0;
        for(int left = 0; left < n; left++)
        {
            for(int right = left; right < n; right++)
            {
                if(preSum[right + 1] - preSum[left] == k)
                    ans++;
            }
        }
        return ans;
    }
};
```

时间复杂度：$O(n^2)$ 

空间复杂度：$O(n)$ 

​	 

#### 前缀和 + 哈希表

我们看到，实际上我们并不需要去把所有的数组给检索处理，我们关心的是有多少个数组的前缀和为 `k` 

那么这里有一个问题是，如何通过不枚举所有数组进而得到前缀和为 `k` 的个数

我们想到，求数组当中某一部分的和是通过前缀和数组两个部分来相减

具体地，求数组当中序列号为 $[i,j]$ 部分的和，有：
$$
sum=preSum[j]-preSum[i-1]
$$
也就是说，我们通过不断记录之前得到的前缀和的值，只要当前遍历得到的前缀和与之前记录的相差为 $k$ ，那么我们就可以让出现次数加一

具体地，我们建立一个哈希表，以前缀和为键，以该前缀和出现的次数为值，通过检索 `curSum - k` 是否在哈希表中进而便可以解决问题

在哈希表的初始化部分，由于前缀和为 0 也是一种情况，因此我们需要对哈希表写入 `mp[0] = 1` 

我们只需要每次将当前记录得到的前缀和加入到哈希表即可，连前缀和数组都不需要构建

完整代码如下：

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) 
    {
        unordered_map<int, int>mp;
        mp[0] = 1;
        int ans = 0, sum = 0;
        for(int x : nums)
        {
            sum += x;
            if(mp.find(sum - k) != mp.end())
                ans += mp[sum - k];
            mp[sum]++;
        }
        return ans;
    }
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(n)$ 