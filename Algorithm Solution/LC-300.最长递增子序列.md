---
title: LC 300.最长递增子序列
tags: [动态规划, 二分查找, 线段树, 残留]
categories: Algorithm Solution
---

#### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

 

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

 

**进阶：**

- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

​	 

#### 动态规划

我们定义一个二维数组 `dp[i][j]` ，表示考虑前 `i` 个数，以下标 `j` 结尾的数的最长递增子序列的长度

通过空间压缩，我们只需要用一维的 `dp[j]` 来存储整个 `dp` 数组

我们有以下状态方程
$$
dp[j]=max(dp[j'])+1,\ j'\le i
$$
最后我们再取整个 `dp` 数组的最大值即可

不难写出如下代码：

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int>dp(n, 1);
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < i; j++)
            {
                if(nums[j] < nums[i])
                    dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        int ret = 0;
        for(int i = 0; i < n; i++)
            ret = max(ret, dp[i]);
        return ret;
    }
};
```

时间复杂度：$O(n^2)$ 
空间复杂度：$O(n)$ 

​	 

#### 线段树

显然，$O(n^2)$ 的时间复杂度我们是不能接受的，我们需要优化一下上面的代码

我们看状态转移方程：
$$
dp[j]=max(dp[j'])+1,\ j\le i
$$
**等号的左边，是对数组元素的单点修改**，**等号的右边，是对数组元素求区间和**

那么，我们是不是就可以想到用线段树来解决这道题

我们看，区间求最大值，我们的对象是区间整体的最大值，在上面的转移方程当中，求最大值的对象是 `dp` 数组当中的数值，这个就是数组的元素值

并且我们所求区间的范围为所有小于 `nums[i]` 的数，这个就是线段树的数组下标

也就是说，我们线段树的数组下标需要用 **`nums` 数组来做**，数组对应的值就是**以当前该元素为结尾的最长递增子序列**

明确这两点之后，这道题也就不难了

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) 
    {
        int n = nums.size();
        int res = 0;
        for(int i = 0; i < n; i++)
        {
            int ans = 1 + query(root, 0, 1e5, 0, nums[i] + 1e4 - 1);
			//以nums[i]作为数组的下标
			//叶子节点的值存放的是以这个数结尾的最长递增子序列
            update(root, 0, 1e5, nums[i] + 1e4, nums[i] + 1e4, ans);
            res = max(res, ans);
        }
        return res;
    }
private:
    class Node
	{
	public:
		Node* left,* right;
		int val, lazy;
		Node() : left(nullptr), right(nullptr), val(0), lazy(0)
		{  }
	};

    Node* root = new Node();

	void pushUp(Node* root)
	{
		root->val = max(root->left->val, root->right->val);
	}

	//leftnum represents the number of the left sub-interval
	void pushDown(Node* root, int leftnum, int rightnum)
	{
		if (root->left == nullptr) root->left = new Node();
		if (root->right == nullptr) root->right = new Node();
		if (root->lazy == 0) return;
		root->left->val = root->lazy;
		root->right->val = root->lazy;
		root->left->lazy = root->lazy;
		root->right->lazy = root->lazy;
		root->lazy = 0;
	}
	/*
	* root is currently traversed interval, and interval [l, r] is the intervals represented by current node
	* interval [L, R] is interval ready to be upddate
	* each element will increase val
	* 
	* This function should be called like this: update(root, 0, n, L, R, val);
	* interval [0, n] could be used without an interval [1, n]
	*/
	void update(Node* root, int l, int r, int L, int R, int val)
	{
		if (L <= l && r <= R)
		{
			root->val = val;
			root->lazy = val;
			return;
		}
		int mid = l + (r - l) / 2;
		pushDown(root, mid - l + 1, r - mid);
		if (L <= mid) update(root->left, l, mid, L, R, val);
		if (mid < R) update(root->right, mid + 1, r, L, R, val);
		pushUp(root);
	}

	/*
	* l r L R meaning ibid
	*/
	int query(Node* root, int l, int r, int L, int R)
	{
		if (L <= l && r <= R)
			return root->val;
		int mid = l + (r - l) / 2, ans = 0;
		pushDown(root, mid - l + 1, r - mid);
		if (L <= mid) ans = query(root->left, l, mid, L, R);
		if (mid < R) ans = max(ans, query(root->right, mid + 1, r, L, R));
		return ans;
	}
};
```

时间复杂度：$O(nlogn)$ 

空间复杂度：$O(n)$ 