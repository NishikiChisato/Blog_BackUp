---
title: 动规 混合背包问题
tags: [动态规划, 背包]
categories: Algorithm Solution
---

### 混合背包

前面我们详细分析了三种背包问题，分别是 [0-1背包问题](https://nishikichisato.github.io/2022/08/02/Algorithm Solution/动规-0-1背包问题/) 、 [完全背包问题](https://nishikichisato.github.io/2022/09/12/Algorithm Solution/动规-完全背包问题/) 、 [多重背包问题](https://nishikichisato.github.io/2022/09/14/Algorithm Solution/动规-多重背包问题/) 、 [多重背包之单调队列优化](https://nishikichisato.github.io/2022/09/16/Algorithm Solution/多重背包之单调队列优化/) 

在状态的定义上，三种背包都有「不超过」和「恰好」两种定义，关于这一点我们之前做的题也见过了

* 对于「不超过」的定义，`dp[0][j] = 0` 均为有效值
  * 这表示，考虑前 0 个物品，那么背包容量必然不可能超过 0 ，因此均为有效值
* 对于「恰好」的定义，只有 `dp[0][0] = 0` 才是有效值
  * 显然，只有当什么都不选的时候，才恰好满足背包空间为 0 ，因此只有 `dp[0][0] = 0` 才是有效值

 我们来看一道将上面所有背包混合起来的问题

问题描述：

有 `N` 种物品和一个最多能装 `V` 的背包，第 `i` 件物品的价值是 `w[i]` 、体积是 `v[i]` 、数量是 `s[i]` ，有：

* 当 `s[i] > 0` 时，`s[i]` 的值就是该物品可用的次数
* 当 `s[i] = 0` 时，该物品可以用无数次
* 当 `s[i] = -1` 时，该物品只能用一次

​	 

#### 空间优化

这里就是将上面三种背包全部综合了一下，其实也不难

我们知道，0-1 背包和完全背包只是遍历的顺序不一样而已，前者从前向后，后者从后向前

而多重背包可用通过二进制优化，最终的处理方案跟 0-1 背包完全一样

由于最后的处理只在遍历顺序上有不同，那么我们先对所有物品进行二进制处理，最后转换成 0-1 背包就行

实际上很简单，这个东西，我直接给代码吧，前面三个会，这个压根就没有思维难度

```cpp
int back(int N, int V, vector<int>& s, vector<int>& v, vector<int>& w)
{
    vector<int>worth;
    vector<int>volume;
    for (int i = 0; i < N; i++)
    {
        int elem = s[i];
        if (elem > 0)//多重背包
        {
            for (int j = 1; j < elem; j *= 2)
            {
                elem -= j;
                worth.push_back(j * w[i]);
                volume.push_back(j * v[i]);
            }
            if (elem > 0)
            {
                worth.push_back(elem * w[i]);
                volume.push_back(elem * v[i]);
            }
        }
        else if (elem == 0)//完全背包
        {
            worth.push_back(-w[i]);//用负值标记
            volume.push_back(v[i]);
        }
        else
        {
            worth.push_back(w[i]);
            volume.push_back(v[i]);
        }
    }
    vector<int>dp(V + 1, 0);
    for (int i = 0; i < N; i++)
    {
        int vi = v[i];
        int wi = w[i];
        if (wi < 0)
            for (int j = 0; j < V; j++)//完全背包的处理
                dp[j] = max(dp[j], dp[j - vi] - wi);
        else
            for (int j = V; j >= vi; j--)//0-1背包和多重背包的处理
                dp[j] = max(dp[j], dp[j - vi] + wi);
    }
    return dp[V];
}
```

这东西时空复杂度没法算，所以我们直接忽视它

这里说一下为什么里面可以用 `if` 来分开

你想嘛，`dp[j]` 表示每一层，那么对于同一层而言，`dp[j]` 的值表示的是**选择物品多少而对应的价值**

因此在遍历内层循环的时候，我们可用通过这个物品的价值正负（经过预先处理），得知该物品可用选择的次数

再根据选择的次数按照不同的背包来进行处理，0-1 背包就从后往前，完全背包就从前往后遍历

