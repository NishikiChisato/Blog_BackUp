---
title: 动规 0-1背包问题
tags: [背包, 动态规划]
categories: Algorithm Solution
---

### 0 - 1 背包

问题描述：

有 `N` 件物品和一个最多能背重量为 `W` 的背包。第 `i` 件物品的重量是 `weight[i]`，得到的价值是 `value[i] `

**每件物品只能用一次**，求解将哪些物品装入背包里使得物品价值总和最大

​		 

### 朴素解法

背包问题是典型的动态规划。在此，我们需要明确两个概念：**「选择」**和**「状态」**。

什么叫「选择」？对于一个物品 `i` ，我可以**选择**将它放入背包还是不放人背包。

而「选择」与「状态」之间的联系为：**「选择」会引发「状态」的改变**。基于这一点，这里的「状态」有：背包的重量、可供选择的物品。

这里你会问：背包当前的价值算不算是状态？

答案是：不能算，这只是某一个状态下所对应的值而已，仅仅是数值，不是状态。

在这里，我们可以给出 `dp` 数组的定义了：`dp[i][j]` 表示**在前 `i` 个物品中进行挑选，在背包容量为 `j` 的状态下的最大价值**。

然后，我们再看初始化。

显然，在前 0 个物品中挑选的最大价值是 0 。在背包容量为 0 的条件下挑选的最大价值也是 0 。故：`dp[0][j] = 0, dp[i][0] = 0` 。

然后我们来看状态转移方程的部分。

我们的递归从 1 开始，因此**数组下标 `i - 1` 表示第 `i` 个物品**（这一点很重要啊）。那么对于第 `i` 个物品就有选与不选两种「选择」。

* 如果我**考察**第 `i` 个物品但**不将它加入到背包中**

  我们容易忽略的一个事实是，如果我要考察是否选择第 `i` 个物品的时候，**我一定是在前面 `i-1` 个物品已经选择完的基础上进行讨论的**，那么这一步，我们可以确定前面 `i - 1` 个物品已经选完所对应的 `dp` 数组前面部分为 `dp[i - 1][]`

  然后，我们目前是在考察第 `i` 个物品，也就是说我们现在是要求的 `dp` 数组的前面部分是 `dp[i][]` 

  由于不将第 `i` 个物品加入背包，因此 `dp` 数组的后面部分相同，全部写 `dp[][j]` 

  所以这种情况对应的状态转移方程为：`dp[i][j] = dp[i - 1][j]`

* 如果我考察第 `i` 个物品并**将它加入到背包中**

  同样地，我们从**对前面 `i-1` 个物品已经选完**的基础上开始讨论，此时所对应的 `dp` 数组的前半部分为 `dp[i-1][]` 

  然后，我们考虑**对前面 `i` 个物品全部选完**所对应的 `dp` 数组，也就是我们要求的。这里的前半部分为 `dp[i][]`

  我们知道，状态 `i-1` 与状态 `i` 相比唯一的不同是**背包所限定的重量不一样**，二者之间的差值为**第 `i` 个物品的重量**（也就是 `weight[i - 1]` ，还记得吗？**下标 `i - 1` 表示第 `i` 个物品**）。我们目前对**这个部分**所能确定的只有差值，其实也只需要差值。

  因此，对于 `dp` 数组的第二部分，我们有两种写法

  `dp[i - 1][j - weight[i - 1]]` 与 `dp[i][j]` 或者 `dp[i - 1][j]` 与 `dp[i][j + weight[i - 1]]` 

  显然，后者十分的不合理。为什么？

  我们想想动态规划的核心，我们是需要通过 `dp[0 到 i - 1]` 去求 `dp[i]` 。也就是说，`dp[i]` 之后的数我们还不会遍历到，因此后者在实际的遍历当中是错误的。

  然后，对于状态 `i - 1` ，我们加上第 `i` 个物品的价值 `value[i - 1]` 之后就可以得出状态 `i` 了

  因此这种情况的状态转移方程为：`dp[i][j] = do[i - 1][j - weight[i - 1]] + value[i - 1]`

那么到此为止，我对于这玩意所有的疑问都已经解决了，下面给出相应代码：

```cpp
int back(int N, int W, vector<int>& weight, vector<int>& value)
{
    vector<vector<int>>dp(N + 1, vector<int>(W + 1, 0));
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= W; j++)
        {
            if (j > weight[i - 1])//背包装得下
                dp[i][j] = max(dp[i - 1][j], 
                               dp[i - 1][j - weight[i - 1]] + value[i - 1]);
        	else                  //背包装不下，等价于不装物品的情况
                dp[i][j] = dp[i - 1][j];
        }
    }
    return dp[N][W];
}
```

时间复杂度：$O(n^2)$

空间复杂度：$O(n^2)$

​	 

### 空间优化

上面的代码可以通过滚动数组将空间复杂度压缩到 $O(n)$ ，但数组依旧是二维的，我们在这里介绍一种只需要一维的数组空间实现的算法，当然，空间复杂度还是 $O(n)$ ，但这个算法的思想很重要

上面我们看到，状态 `dp[i][j]` 的数值仅由状态 `dp[i - 1][j]` 与状态 `dp[i - 1][j - weight[i - 1]]` 转移而来

联想我们之前 [DP 数组空间压缩](https://nishikichisato.github.io/2022/09/06/Algorithm Solution/DP-数组空间压缩/) 的技巧，我们只定义一个一维数组 `dp[w + 1]` 

在为对该数组赋值的时候，数组里面的数值就表示 `dp[i - 1]` 

我们只需要将 `dp[j]` 的数组与 `dp[j - weight[i - 1]]` 保存下来给 `dp[j]` 赋值即可

但这样其实还是有点麻烦的，我们直接反过来遍历，这样就不需要保存了

完整代码如下：

```cpp
int back(int N, int W, vector<int>& weight, vector<int>& value)
{
    vector<int>dp(W + 1);
    for (int i = 1; i <= N; i++)
    {
        for (int j = W; j >= weight[i - 1]; j--)
        {
            dp[j] = max(dp[j], dp[j - weight[i - 1]]);
        }
    }
    return dp[N][W];
}
```

时间复杂度：$O(n^2)$ 

空间复杂度：$O(n)$ 
