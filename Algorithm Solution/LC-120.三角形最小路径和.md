---
title: LC 120.三角形最小路径和
tags: [路径问题, 动态规划]
categories: Algorithm Solution
---



#### [120. 三角形最小路径和](https://leetcode.cn/problems/triangle/)

给定一个三角形 `triangle` ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

```
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```



#### DP 数组

前面做了那么多道的最短路径，现在这种题目已经是轻车熟路了

我们定义 `dp[i][j]` 表示到达点 $(i,\ j)$ 所需的最短路径和

在这道题里面，我们需要找出自顶向下的最短路径和，也就是我们需要找出 `dp` 数组最后一行当中的最小值，即 `dp[n-1][j]` 的最小值

然后我们来考虑一下状态转移方程。这种路径问题，做多了真的是有感觉

我们考虑**其它点应该如何转移到点** $(i,\ j)$ 这个问题，即对于所求 `dp[i][j]` ，我们有且仅有如下两种方式转移过来

* 正上方
* 左上方

接着我们考虑这两种情况的限制条件，不难想到：

对于位置第 `j = 0` 列，**只可以**正上方转移过来

对于位置 `j == i` ，**只可以**从左上方转移过来

我们用区间的角度来理解这两句话就是：

若 `j == 0` ，则只能从正上方转移

若 `0 < j < i` ，则既可以从正上也可以从左上转移

若 `j == i` ，即只能从左上转移

实际上，有这三句就已经足够我们写转移方程了，但这里还可以继续讨论

刚刚我们是从区间也就是 `j` 的取值来考虑所得到的结果，对于这个结果，我们从**「可以从哪个方向转移过来」**来考虑 `j` 的取值

若**一定能**从正上方转移，则 `j < i` ，只需要把只能从左上方转移过来的条件排除在外即可，其转移方程为 `dp[i][j] = dp[i - 1][j]`

若**一定能**从左上方转移过来，则 `j > 0` ，同理，把只能从正上方转移过来的情况排除，其转移方程为 `dp[i][j] = dp[i - 1][j - 1]` 

讨论到这里，最主要的就已经结束了，还有一个细节：

上面这两种情况是相互独立的，也就是分别由两个 `if` 来进行判断

我们最终的 `dp[i][j]` 的取值需要取二者的较小值（如果二者均成立）

我原先的想法是，分别用两个变量记录下这两个数（没有成立的那个用最大值标记），然后在对 `dp[i][j]` 赋值的时候对这两个变量取较小值即可

实际上还有更简单的办法：先对 `dp[i][j]` 赋最大值，然后分别于那两个转移过来的值作比较即可，这样一定可以取到最小值

就算那两个 `if` 都不成立，在下一层当中也会直接忽略掉这个值（因为它是最大值）

具体代码如下：

```cpp
class Solution {
public:
	int minimumTotal(vector<vector<int>>& triangle)
	{
		int n = triangle.size();
		vector<vector<int>>dp(n, vector<int>(n, 0));
		dp[0][0] = triangle[0][0];
		for (int i = 1; i < n; i++)
		{
			for (int j = 0; j <= i; j++)
			{
				dp[i][j] = INT32_MAX;
				int val = triangle[i][j];
				if (j < i)
					dp[i][j] = min(dp[i][j], dp[i - 1][j] + val);
				if (j > 0)
					dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + val);
			}
		}
		int ret = INT32_MAX;
		for (int m : dp[n - 1])//求最小值
			ret = min(ret, m);
		return ret;
	}
};
```

时间复杂度：$O(n^2)$ 

空间复杂度：$O(n^2)$ 



#### DP 数组 + 滚动数组压缩

滚动数组的状态压缩没有任何的思维难度，至少看起来是这样

我们直接将**第一维**从 `i` 改为 `2` 

然后将所有的 `dp[i]` 全部改为 `dp[i % 2]` 或者 `dp[i & 1]` ，这里推荐用后者，毕竟可移植性好

最起码，从做法上看，没有任何难度，但我还是解释一下

我们单单看 `dp` 数组的第一维，`dp[i]` 的取值**只依靠**`dp[i - 1]` ，也就是该位置前面那一个的值（记住，我们只看第一维）

那么，对于原 `dp` 数组当中的**某一行**，我把所有**奇数索引**对应的值投影到 `dp[1]` ，所有**偶数索引**对应的值投影到 `dp[0]` ，由于每一次对 `dp[i]` 的赋值只依靠前一个的值，那么我们让 `dp[0]` 和 `dp[1]` 的值不断更新即可，这也就是滚动数组嘛

根本没有任何的思维难度。。。。。。

具体代码如下：

```cpp
class Solution {
public:
	int minimumTotal(vector<vector<int>>& triangle)
	{
		int n = triangle.size();
		vector<vector<int>>dp(2, vector<int>(n, 0));
		dp[0][0] = triangle[0][0];
		for (int i = 1; i < n; i++)
		{
			for (int j = 0; j <= i; j++)
			{
				dp[i & 1][j] = INT32_MAX;
				int val = triangle[i][j];
				if (j < i)
					dp[i & 1][j] = min(dp[i & 1][j], dp[(i - 1) & 1][j] + val);
				if (j > 0)
					dp[i & 1][j] = min(dp[i & 1][j], dp[(i - 1) & 1][j - 1] + val);
			}
		}
		int ret = INT32_MAX;
		for (int m : dp[(n - 1) & 1])
			ret = min(ret, m);
		return ret;
	}
};
```

时间复杂度：$O(n^2)$

空间复杂度：$O(n)$ 