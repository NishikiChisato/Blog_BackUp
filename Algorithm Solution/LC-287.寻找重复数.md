---
title: LC 287.寻找重复数
tags: [二分查找, 双指针, 哈希表]
categories: Algorithm Solution
---

#### [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

**示例 1：**

```
输入：nums = [1,3,4,2,2]
输出：2
```

**示例 2：**

```
输入：nums = [3,1,3,4,2]
输出：3
```

提示：

* 1 <= n <= 105
* nums.length == n + 1
* 1 <= nums[i] <= n
* nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次


进阶：

* 如何证明 nums 中至少存在一个重复的数字?
* 你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？

​	 

#### 原地哈希

由于存在 `n+1` 个数，每个数字都是 `1 ~ n` ，那么就必然有**一个**重复数

我们将元素 `x` 移动到索引 `x - 1` 处，那么对于任意一个不重复的元素，它必然有唯一确定的位置

如果存在重复元素，那么必然会出现位置想碰撞，进而可以找到该元素

具体地，我们设 `idx = x - 1` ，那么原本的移动就相当于将数组排序，对于每个元素 `x` ，有：$index(x)=x-1$ ，即元素 `x` 的下标就是 `idx` ，如果不满足这一点就说明存在重复元素

完整代码如下：

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) 
    {
        for(int i = 0; i < nums.size();)
        {
            int x = nums[i], idx = x - 1;
            if(nums[idx] != x)
                swap(nums[idx], nums[i]);
            else
            {
                if(i != x - 1)
                    return x;
                i++;
            }
        }
        return -1;
    }
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(1)$ 

​	 

#### 二分查找

这道题本质上就是在区间 `[1, n]` 当中寻找一个数

在一个有序的区间内寻找一个数，我们可以用二分查找的思想

我们假定数组 `nums` 是有序的，并设其区间中点为 `mid` （下标从 1 开始计数）

如果左半边的元素个数**刚好** 为 `mid` ，那么说明重复元素必然不在左边

进而，我们只需要查找右半边的区间即可

在实际操作上，我们统计 `nums` 中**小于等于** `mid` 的元素个数，并以此来判断需要查找哪个区间

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) 
    {
        int n = nums.size();
        int left = 1, right = n;
        while(left < right)
        {
            int mid = left + (right - left) / 2;
            int count = 0;
            for(int i : nums)
                if(i <= mid)
                    count++;
            if(count > mid)
                right = mid;
            else left = mid + 1;
        }
        return left;
    }
};
```

时间复杂度：$O(nlogn)$ 

空间复杂度：$O(1)$ 

​	 

#### 双指针

在这里，我们可以仿照并查集的定义，将数组索引表示为元素编号，数组元素表示为下一个元素的链接

那么如果一个数组当中出现重复元素，这就说明有两个元素的链接相同，也就是说，必然会形成环

环的入口元素就是我们要找到重复数

具体地，我们定义两个指针 `slow` 和 `fast` ，有：$v(fast)=2v(slow)$ 

设开头点为 $S$ ，环的入口点为 $I$ ，相遇点为 $M$ ，有：

设 $x=\vec{SI},\ y=\vec{IM},\ z=\vec{MI}$ ，显然：

$S_{slow}=x+y,\ S_{fast}=x+k(y+z)+y$ 

因为 $S_{fast}=2S_{slow}$ ，有：$z=y$ 

也就是说，在二者相遇后，相遇点的距离到环入口点的距离跟开始点到环入口点的距离相同

这里我们再定义两个指针，让它们同时移动，只要二者最后相等，这就是我们想要的答案

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) 
    {
        int slow = 0, fast = 0;
        slow = nums[slow];
        fast = nums[nums[fast]];
        while(slow != fast)
        {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        int pre = 0, cur = slow;
        while(pre != cur)
        {
            pre = nums[pre];
            cur = nums[cur];
        }
        return pre;
    }
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(1)$ 