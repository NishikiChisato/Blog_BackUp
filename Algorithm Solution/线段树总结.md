---
title: 线段树总结
tags: [线段树]
categories: Algorithm Solution
---

## 线段树的引入

假如我们有两个需求：

* 对数组当中任意区间的元素进行求和
* 对数组当中任意区间的元素进行增加

最朴素的想法，我们采取维护一个 `n` 个元素的数组这种思路

我们所需的空间复杂度为：$O(n)$ 

对于需求一，时间复杂度为：$O(n)$ 

对于需求二，时间复杂度为：$O(n)$ 

为了便于讨论，下面我们统一用区间查询来代替这两个需求

如果我们从区间的角度来看待这个问题

上面这种思路，就相当于是维护了 $n$ 个区间，每个区间**只有一个元素**

如果，我们在上面的基础上，每一次都维护一个更大的区间，也就是每个区间**只有两个元素**

那么总的区间个数就是 $n+n/2$ ，而我们对区间查询操作的时间复杂度是不是也可以相应的减小一半？也就是 $O(n/2)$ 

为什么？因为大体上，原先需要遍历两次才能解决的情况现在只需要遍历一次就能解决，因此总体的时间复杂度能降一半

我们继续这个思路，再上面的基础上维护一个更大的区间，每个区间有 4 个、8 个元素等等，我们逐渐添加

最终，我们所维护的区间个数为：$n+n/2+n/4+n/8+\cdots +2+1=2n-1$ 

区间总个数为 $2n-1$ 。如果抽象成满二叉树的话，总的节点个数为 $2n-1$ ，高度为 $log_2n$ ，其中**二叉树的每个节点都表示一段区间** 

如果不是满二叉树，我们取最极限的情况，也就是节点数为 $n$ 的那一层下面还有一层，这一层最大数量为 $2n$ ，这个数是取不到的。也就是说，最极限的情况是，需要的空间为 $O(4n-1)$ 

因此，我们只需要开 $4n$ 大小的空间就足够存储这棵二叉树了

我们再来看查询的时间复杂度。显然，每次都降一半，但具体会降多少次我们很难确定。我们可以从二叉树的角度来看待这个问题

对于任意长度的区间查询，我们最坏的情况是二叉树的每一层都需要选择一个区间来拼成最终的区间，而二叉树有 $logn$ 层，因此我们可以得出查询的时间复杂度为 $logn$ 级别

​	 

## 线段树的定义

上面我们说到，我们用**二叉树的每个节点来表示一个区间**，这句话的意思是**节点所在的位置不同表示的区间也不同**。但我们到此为止并没有给出节点数值的具体含义

实际上，节点数值的含义可以根据需要自行调整，只不过需要满足**该节点的值可以由两个子节点求出**，也就是节点数值的意义需要能够满足「区间加法」

满足区间加法的有：

* 区间数字和 「总数字和等于两个子区间的数字和」
* 最大公因数（GCD） 「总 GCD = GCD（左子树 GCD，右子树 GCD ）」
* 最大值 「总最大值等于左子树最大值与右子树最大值的较大值」

不满足区间加法的有：

* 众数 「知道两个子区间的众数没办法求整个区间的众数」

​	 

## 数据结构定义与实现

这里我们采取链式存储的形式，因为后面涉及到动态开点，链式的方便一点

不过论书写速度的话还是数组形式的更快

我们给出这棵二叉树的节点定义：

```cpp
class Node
{
    public:
    Node* left,* right;
    int val;
    Node() : left(nullptr), right(nullptr), val(0)
    {  }
};
```

节点值 `val` 的意义根据需求来确定。再次强调，这个**节点所表示的区间由这个节点所在的位置决定**，这个区间是可以不用写在节点内部的（当然写也没关系）

前面我们说到，二叉树的节点更新是需要通过两个子节点来实现的，这种更新是自下而上的，因此我们需要一个 `pushUp` 函数来实现对**当前**节点的更新操作（更新的值直接由两个子节点取得）

```cpp
void pushUp(Node* root)
{
    root->val = root->left->val + root->right->val;
}
```

当我们需要对某一个区间进行更新时，最朴素的做法是直接将这个区间的每一个元素增加一个值，放在二叉树里面就是将对应叶子节点增加一个数值

但是，如果我们每次都需要遍历到叶子节点的话，这个时间复杂度是非常大的，这个时候我们可以给每个节点打上一个 `lazy tag` ，来表示**当前节点以下的所有节点的变化量**，那么这样的话我们便不用访问所有的叶子节点就也能实现对数组当中每个元素的修改了

这里实际上就是一个懒惰思想的应用：如果不需要使用后面的元素，那么我们就不修改它们，只修改当前元素

加上 `lazy tag` 之后的节点定义：

```cpp
class Node
{
    public:
    Node* left,* right;
    int val, lazy;
    Node() : left(nullptr), right(nullptr), val(0), lazy(0)
    {  }
};
```

我们需要一个能够将 `lazy` 标记向下传递的函数，每次只需要传递一层即可

```cpp
void pushDown(Node* root, int leftnum, int rightnum)
{
    if (root->left == nullptr) root->left = new Node();
    if (root->right == nullptr) root->right = new Node();
    if (root->lazy == 0) return;
    root->left->val += root->lazy * leftnum;
    root->right->val += root->lazy * rightnum;
    root->left->lazy += root->lazy;
    root->right->lazy += root->lazy;
    root->lazy = 0;//对当前节点的标记进行清除
}
```

需要进行说明的是，由于我们每个节点都表示一个区间的和，因此对区间内每个数增加一个值 `val` 的时候，上层节点所增加的数组是 `val` 乘上它所对应的元素数量，这条规则对于左右节点同理，因此我们需要两个参数来表示左右节点的元素数量

接下来便是 `update` 函数

```cpp
void update(Node* root, int l, int r, int L, int R, int val)
{
    if (L <= l && r <= R)
    {
        root->val += (r - l + 1) * val;
        root->lazy += val;
        return;
    }
    int mid = l + (r - l) / 2;
    pushDown(root, mid - l + 1, r - mid);
    if (L <= mid) update(root->left, l, mid, L, R, val);
    if (mid < R) update(root->right, mid + 1, r, L, R, val);
    pushUp(root);
}
```

其中 `l` 与 `r` 表示当前节点所表示的区间，`L` 与 `R` 表示待更新的区间

如果当前区间完全被待更新区间所包含，那么直接修改当前区间的值并**返回**

如果当前区间的左区间在待修改区间内，那么递归左区间

右区间同理，最后我们更新当前节点的值即可

对于查询操作也是同理，理解上面那个这个也就不难了

```cpp
int query(Node* root, int l, int r, int L, int R)
{
    if (L <= l && r <= R)
        return root->val;
    int mid = l + (r - l) / 2, ans = 0;
    pushDown(root, mid - l + 1, r - mid);
    if (L <= mid) ans += query(root->left, l, mid, L, R);
    if (mid < R) ans += query(root->right, mid + 1, r, L, R);
    return ans;
}
```

最后我们给出整个二叉树的代码实现，现在这棵二叉树正式更名为线段树

这里我们给出的是动态开点的写法

```cpp
class SegmentTreeDynamic
{
private:
	class Node
	{
	public:
		Node* left,* right;
		int val, lazy;
		Node() : left(nullptr), right(nullptr), val(0), lazy(0)
		{  }
	};

	void pushUp(Node* root)
	{
		root->val = root->left->val + root->right->val;
	}

	//leftnum represents the number of the left sub-interval
	void pushDown(Node* root, int leftnum, int rightnum)
	{
		if (root->left == nullptr) root->left = new Node();
		if (root->right == nullptr) root->right = new Node();
		if (root->lazy == 0) return;
		root->left->val += root->lazy * leftnum;
		root->right->val += root->lazy * rightnum;
		root->left->lazy += root->lazy;
		root->right->lazy += root->lazy;
		root->lazy = 0;
	}

	/*
	* root is currently traversed interval, and interval [l, r] is the intervals represented by current node
	* interval [L, R] is interval ready to be upddate
	* each element will increase val
	* 
	* This function should be called like this: update(root, 0, n, L, R, val);
	* interval [0, n] could be used without an interval [1, n]
	*/
	void update(Node* root, int l, int r, int L, int R, int val)
	{
		if (L <= l && r <= R)
		{
			root->val += (r - l + 1) * val;
			root->lazy += val;
			return;
		}
		int mid = l + (r - l) / 2;
		pushDown(root, mid - l + 1, r - mid);
		if (L <= mid) update(root->left, l, mid, L, R, val);
		if (mid < R) update(root->right, mid + 1, r, L, R, val);
		pushUp(root);
	}

	/*
	* l r L R meaning ibid
	*/
	int query(Node* root, int l, int r, int L, int R)
	{
		if (L <= l && r <= R)
			return root->val;
		int mid = l + (r - l) / 2, ans = 0;
		pushDown(root, mid - l + 1, r - mid);
		if (L <= mid) ans += query(root->left, l, mid, L, R);
		if (mid < R) ans += query(root->right, mid + 1, r, L, R);
		return ans;
	}
};
```

实际上，线段树还有数组的写法

我们以下标 1 作为整棵树的根节点，由此我们有：

对于编号为 `i` 的节点

* 其左孩子的编号为 `2 * i` ，用位运算就是 `i << 1` 
* 其右孩子的编号为 `2 * i + 1` ，用位运算就是 `i << 1 | 1` 

写法非常的简单，我们就不过多赘述了

