---
title: 动规 分组背包
tags: [动态规划, 背包]
categories: Algorithm Solution
---

### 分组背包

问题描述：

给定 **`N` 个物品组**和一个容量为 `V` 的背包，第 `i` 个物品组共有 `s[i]` 个物品，第 `i` 组第 `j` 件物品体积为 `v[i][j]` 、价值为 `w[i][j]` 

每组有若干个物品，**同一组内的物品最多只能选择一个**，求解将哪些物品装入背包使得背包价值最大

​	 

### 空间优化

这里我们直接给出空间优化的解法

我们考虑第 $i$ 组当中的物品，由于同一组当中的物品只能选择一个，因此我们有：

当我不选择物品时，有：$dp[i][j]=dp[i-1][j]$ 

当我选择第 $0$ 个物品时，有：$dp[i][j] = dp[i-1][j-v[i][0]]+w[i][0]$ 

当我选择第 $1$ 个物品时，有：$dp[i][j]=dp[i-1][j-v[i][1]]+w[i][1]$ 

当我选择第 $2$ 个物品时，有：$dp[i][j]=dp[i-1][j-v[i][2]]+w[i][2]$ 

$\cdots$

当我选择第 $k$ 个物品时，有：$dp[i][j]=dp[i-1][j-v[i][k]]+w[i][k]$ 

由于我们需要求最大值，因此最终结果就是求上面所有值的最大值，即：
$$
dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i][k]]+w[i][k]), \text{其中}\ 0\le k \le s[i]
$$
当我们将空间进行压缩时，由于需要上一层的数据，因此需要从后往前进行遍历

完整代码如下：

```cpp
int back(int N, int V, vector<int>& s, vector<vector<int>>& v, vector<vector<int>>& w)
{
    vector<int>dp(V + 1, 0);
    for (int i = 0; i < N; i++)
    {
        int si = s[i];
        vector<int>vi = v[i];
        vector<int>wi = w[i];
        for (int j = V; j >= 0; j--)
        {
            for (int k = 0; k < si; k++)
                if (j - vi[k] >= 0)
                    dp[j] = max(dp[j], dp[j - vi[k]] + wi[k]);
        }
    }
    return dp[V];
}
```

时间复杂度：$O(n*\sum^{n-1}_{i=0}s[i])$ ，实际上就是 $O(n^3)$ 

空间复杂度：$O(n)$ 