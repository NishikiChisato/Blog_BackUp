---
title: 动规 完全背包问题
tags: [动态规划, 背包]
categories: Algorithm Solution
---

### 完全背包

问题描述：

有 **`N` 种物品**和一个最多能背重量为 `W` 的背包。第 `i` 件物品的重量是 `weight[i]` ，得到的价值是 `value[i]`

**每件物品可以用无数次**，求解将哪些物品装入背包里使得物品价值总和最大



在 0-1 背包的基础上，只需要添加「**物品可以被无限次选择」**这个条件，就成了完全背包

关于 0-1 背包，我们在 [动规 0-1背包问题](https://nishikichisato.github.io/2022/08/02/Algorithm Solution/动规-0-1背包问题/) 这里有过详细的说明，这里不再过多赘述

我们知道，0-1 背包的状态转移方程为（这里我们作出偏移，下面的讨论均是基于这一假设）：

$dp[i][j] = max(dp[i-1][j],\ dp[i-1][j-weight[i-1]]+value[i-1])$ 

我们说，完全背包就是在 0-1 背包的基础上，加上了**「物品可以被无限次选择」**这一条件

仿照 0-1 背包的分析思路，我们不难得到：

对于第 `i` 件物品

我们选择 0 次，有：$dp[i][j] = dp[i-1][j]$

我们选择 1 次，有：$dp[i][j]=dp[i-1][j-weight[i-1]]+value[i-1]$ 

我们选择 2 次，有：$dp[i][j]=dp[i-1][j-2*weight[i-1]]+2*value[i-1]$ 

$\cdots$

不失一般性地，我们对第 `i` 件物品选择 $k$ 次，显然：

$dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*weight[i-1]]+k*value[i-1])$ ，其中 $k*weight[i-1]\le j$

我们对上式进行展开，有：

$dp[i][j]=max(dp[i-1][j],\ {\color{violet} dp[i-1][j-w[i-1]]+v[i-1],\ dp[i-1][j-2*w[i-1]]+2*v[i-1],\ \cdots\  })$ 

这里我们用 $w$ 来替换 $weight$ ，用 $v$ 来替换 $value$ 

当我们忽略第一维变化的时候，我们发现，$j$ 的变化是**先相等，后减小**

也就是说，对于上面粉色部分，我们很容易得出如下结论：

$dp[i][j-w[i-1]]=max({\color{violet}dp[i-1][j-w[i-1]],\ dp[i-1][j-2*w[i-1]]+v[i-1],\ \cdots})$  

显然，**两个式子相同颜色部分相差一个恒定值**：$v[i-1]$ 

我们将两式合并，有：

$dp[i][j] = max(dp[i-1][j],dp[i][j-w[i-1]]+v[i-1])$ 

因此，如果我需要求 $dp[i][j]$ 的值，只需要求出 $dp[i-1][j]$ 与 $dp[i][j-w[i-1]]+v[i-1]$ 之间的较大值即可

​	 

简单对比一下：

0-1 背包：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i-1]] + v[i-1])` 

完全背包：`dp[i][j] = max(dp[i-1][j], dp[i][j-w[i-1]] + v[i-1])` 

所以这区别。。。。真不大

下面是完全背包的代码（直接套 0-1 背包就行）：

```cpp
int back(int N, int W, vector<int>& weight, vector<int>& value)
{
    vector<vector<int>>dp(N + 1, vector<int>(W + 1, 0));
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= W; j++)
        {
            if (j > weight[i - 1])//背包装得下
                dp[i][j] = max(dp[i - 1][j], 
                               dp[i][j - weight[i - 1]] + value[i - 1]);
        	else                  //背包装不下，等价于不装物品的情况
                dp[i][j] = dp[i - 1][j];
        }
    }
    return dp[N][W];
}
```



### 空间优化

0-1 背包我们给出了一维数组的压缩方法，这里我们给出完全背包的压缩方法

对于前者而言，我们是从后往前遍历，因为我们不希望赋盖掉 `dp[i-1][j]` 和 `dp[i-1][j-w[i-1]]` 这两个值

而我们来看完全背包的状态转移方程：`dp[i][j] = max(dp[i-1][j], dp[i][j-w[i-1]] + v[i-1])` 

`dp[i][j]` 的值取决于 `dp[i-1][j]` 和 `dp[i][j-w[i-1]]`

对于前者，就是 `dp[j]` 没赋值之前的值

对于后者，它就**是 `dp[j]` 这一行已经赋值的数值**，因此我们直接采取从前往后遍历即可

完整代码如下：

```cpp
int back(int N, int W, vector<int>& weight, vector<int>& value)
{
    vector<int>dp(W + 1);
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= W; j++)
        {
            if (j > weight[i - 1])//背包装得下
                dp[j] = max(dp[j], dp[j - weight[i - 1]] + value[i - 1]);
        	else                  //背包装不下，等价于不装物品的情况
                dp[j] = dp[j];
        }
    }
    return dp[W];
}
```

时间复杂度：$O(n^2)$ 

空间复杂度：$O(n)$ 