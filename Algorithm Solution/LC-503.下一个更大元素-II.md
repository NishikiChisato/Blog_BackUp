---
title: LC 503.下一个更大元素 II
tags: [单调栈, 数组]
categories: Algorithm Solution
---

#### [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

给定一个循环数组 `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 *`nums` 中每个元素的 **下一个更大元素*** 。

数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1` 。

```
输入: nums = [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

​	 

#### 单调栈

关于单调栈使用的基本说明，我们在 [LC 496.下一个更大元素 I](https://nishikichisato.github.io/2022/09/24/Algorithm Solution/LC-496.下一个更大元素-I/) 有过说明，这里直接给代码

实际上就是遍历两倍的数组再取个模就行

```cpp
class Solution {
public:
	vector<int> nextGreaterElements(vector<int>& nums)
	{
		vector<int>ret(nums.size(), -1);
		stack<int>st;
		for (int i = 0; i < 2 * nums.size(); i++)
		{
			while (!st.empty() && nums[st.top()] < nums[i % nums.size()])
			{
				ret[st.top()] = nums[i % nums.size()];
				st.pop();
			}
			st.push(i % nums.size());
		}
		return ret;
	}
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(n)$ 