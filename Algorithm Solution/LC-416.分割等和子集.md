---
title: LC 416.分割等和子集
tags: [动态规划, 背包]
categories: Algorithm Solution
---

#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```



#### 0-1 背包

这道题其实是可以转换成背包问题的

我们需要将这个数组分割成两个**元素和相等的子集**。也就是说，假如这个数组的所有元素和为 `sum` ，我现在要做的就是**确定能否用这个数组的元素凑出 `sum / 2` 。**

也就是说，我从这个集合当中随便选择元素，是否能够满足其元素和为 `sum / 2` 。

因此问题转换成了，给一个可以装 `n` 个物品的背包，每个物品的重量为 `nums[i]` ，背包最大载重为 `sum / 2` ，问能否将这个背包恰好装满。

然后，我们确定 `dp` 数组的含义：`dp[i][j]` 表示在前 `i` 个物品当中任意挑选，能否恰好将重量为 `j` 的背包装满。

我们再来看看 base case 。

显然，对于 `dp[i][0]` 而言，背包最大载重为 0 ，那么这个背包可以认为一直是满的。

对于 `dp[0][j]` 而言，由于可供挑选的物品是 0 ，因此认为不可能将该背包装满。

最后我们分析一下放与不放这两种情况要如何处理。在 0- 1 背包的模型当中我们是取二者的最大值。这是很显然的，毕竟我是要让背包的价值达到最大。在这里，不管是放还是不放，只要能将背包装满，我们就认为这种情况下是 `true` 。

全部代码如下：

```cpp
class Solution {
public:
	bool check(int target, vector<int>& nums)
	{
		//给一个可以装target和n个物品的背包，每个物品重量为nums[i]，是否存在一种装法可以恰好把背包装满
		int n = nums.size();
		vector<vector<bool>>dp(n + 1, vector<bool>(target + 1, false));
		for (int i = 0; i <= n; i++)
			dp[i][0] = true;
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= target; j++)
				if (j - nums[i - 1] >= 0)//背包容量足够
					dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
				else                     //背包容量不够
					dp[i][j] = dp[i - 1][j];
		return dp[n][target];
	}

	bool canPartition(vector<int>& nums)
	{
		int sum = 0;
		for (int n : nums)
			sum += n;
		if (sum % 2 == 1)
			return false;
		return check(sum / 2, nums);
	}
};
```



时间复杂度：$ O(n * target) $ ，$n$ 为数组的元素个数，$target$ 为所有元素和的一半  

空间复杂度：$ O(n * target) $ ，同上