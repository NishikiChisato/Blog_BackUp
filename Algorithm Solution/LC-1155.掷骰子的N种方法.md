---
title: LC 1155.掷骰子的N种方法
tags: [动态规划, 背包]
categories: Algorithm Solution
---

#### [1155. 掷骰子的N种方法](https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/)

这里有 `n` 个一样的骰子，每个骰子上都有 `k` 个面，分别标号为 `1` 到 `k` 。

给定三个整数 `n` , `k` 和 `target` ，返回可能的方式(从总共 `kn` 种方式中)滚动骰子的数量，使正面朝上的数字之和等于 `target` 。

答案可能很大，你需要对 `109 + 7` **取模** 。

```
输入：n = 1, k = 6, target = 3
输出：1
解释：你扔一个有6张脸的骰子。
得到3的和只有一种方法。
```

​	 

#### 朴素二维

这道题其实是一个分组背包的模型，会做分组背包的话，这道题基本没有问题。嘛，就算不会也能做

我们定义 `dp[i][j]` 为：考虑前 `i` 个骰子，当正面之和**恰好**为 `j` 时的所有可能

显然，`dp[0][0] = 1` 

现在，我们考虑哪些状态可以转移到 `dp[i][j]` 

回顾 `dp` 数组的定义，我们既然是考虑 `dp[i][j]` 的值，那么就说明前 `i-1` 个骰子是**已经被我们考虑完毕的**，这一点很关键

那么，我们假设第 `i` 个骰子的值为 `var` ，有： `dp[i][j] = dp[i - 1][j - var]` 

状态 `i` 与状态 `i-1` 之间的差值就是第 `i` 个骰子的数值嘛

由于，第 `i` 个骰子的数值可能有 `k` 个，这对应了 `k` 个状态

这 `k` 个状态都可以转移到 `dp[i][j]` ，因此我们需要将这 `k` 个状态的所有值全部加起来，这个总和就是 `dp[i][j]` 的值，即：
$$
dp[i][j]=\sum^{n}_{i=1}dp[i-1][j-var]
$$


```cpp
class Solution {
public:
	int mod = 1e9 + 7;

	int numRollsToTarget(int n, int k, int target)
	{
		vector<vector<int>>dp(n + 1, vector<int>(target + 1, 0));
		dp[0][0] = 1;
		for (int i = 1; i <= n; i++)
		{
			for (int j = 0; j <= target; j++)
			{
				for (int var = 1; var <= k; var++)
				{
					if (j - var >= 0)
						dp[i][j] = (dp[i][j] + dp[i - 1][j - var]) % mod;
				}
			}
		}
		return dp[n][target];
	}
};
```

时间复杂度：$O(n*k*target)$ 

空间复杂度：$O(n*target)$

​	 

#### 一维压缩

我们直接用一维数组来表示原二维数组当中的某一行，即：

一维数组 `dp[j]` 表示二维数组的第 `dp[i]` 行的所有值

因此，未对 `dp[j]` 赋值前，`dp[j]` 里面的数组表示的是二维数组 `d[i-1]` 这一行的值

对它赋值后，它就表示第 `dp[i]` 行的值

需要注意的是，我们没错都需要对 `dp[j]` 进行清零

这是因为在原二维数组当中，`dp[i]` 行的数值总是为 0

```cpp
class Solution {
public:
    int mod = 1e9 + 7;
    int numRollsToTarget(int n, int k, int target) 
    {
        vector<int>dp(target + 1, 0);
        dp[0] = 1;
        for(int i = 0; i < n; i++)
        {
            for(int j = target; j >= 0; j--)
            {
                dp[j] = 0;//需要归零
                for(int t = 1; t <= k; t++)
                    if(j - t >= 0)
                    {
                        dp[j] += dp[j - t];
                        dp[j] %= mod;
                    }
            }
        }
        return dp[target];
    }
};
```

时间复杂度：$O(n*k*target)$ 

空间复杂度：$O(target)$ 