---
title: LC 494.目标和
tags: [动态规划, 背包]
categories: Algorithm Solution
---

#### [494. 目标和](https://leetcode.cn/problems/target-sum/)

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```



#### DFS

这个数据量才 20 ，并且每个数据只有 + 或者 - 两种操作，直接暴力搜索就完事

```cpp
class Solution {
public:
	int dfs(vector<int>& nums, int target, int pos, int cur)
	{
		if (pos == nums.size())
			return cur == target ? 1 : 0;
		int x = dfs(nums, target, pos + 1, cur + nums[pos]);
		int y = dfs(nums, target, pos + 1, cur - nums[pos]);
		return x + y;
	}

	int findTargetSumWays(vector<int>& nums, int target)
	{
		return dfs(nums, target, 0, 0);
	}
};
```

时间复杂度：$O(2^n)$ 

空间复杂度：$O(2^n)$ 



#### DFS + 记忆化搜索

由于 `taeget` 可能为负数，因此我们并不能直接用数组来去重，这里可以考虑用 `map` 来去重

去重的时候我们需要并不能直接将 `cur` 来作为去重对象

我们去重的目的是避免重复计算，而如何判断此次计算是重复的就是我们需要思考的问题

在传统的动态规划自顶向下的 DFS 的去重当中，归根结底是对 DP 数组下标的去重，因为如果这个下标对应的状态以及算过了，那么就不需要再算了

这里也是同理，我们并不能直接将 `cur` 作为去重对象，原因在于，可能会存在其他的情况相加也等于 `cur` 

我们观察 DFS 函数的参数，我们需要**依靠参数的部分来完成去重**

因为只要两次递归的参数一样，我们就一定能够确定后一次一定是重复的

参数部分是变量的只有 `pos` 和 `cur` 

那么我们可以构造一个字符串，用一个连接符来连接这两个数，这样便构造出了一个可以用于去重的「下标」

```cpp
class Solution {
public:
	map<string, int>cache;

	int dfs(vector<int>& nums, int target, int pos, int cur)
	{
		string str = to_string(pos) + "-" + to_string(cur);
		if (cache.find(str) != cache.end())
			return cache[str];
		if (pos == nums.size())
		{
			cache.insert(pair<string, int>(str, cur == target ? 1 : 0));
			return cache[str];
		}

		int x = dfs(nums, target, pos + 1, cur + nums[pos]);
		int y = dfs(nums, target, pos + 1, cur - nums[pos]);
		cache.insert(pair<string, int>(str, x + y));
		return cache[str];
	}

	int findTargetSumWays(vector<int>& nums, int target)
	{
		return dfs(nums, target, 0, 0);
	}
};
```

时间复杂度：$O(n*\sum_{i=0}^{n}abs(nums[i]))$ ，后者`nums[i]` 当中任意个数的和 ，因为 `pos` 的取值为 $n$ ，而 `cur` 的取值为 $\sum_{i=0}^{n}abs(nums[i])$

空间复杂度：$O(n*\sum_{i=0}^{n}abs(nums[i]))$ 同上



#### DP 数组

我们 `dp` 数组的定义为：考虑前 `i` 个数，恰好凑出 `j` 的所有不同表达式数目

显然，`dp[i][j]` 的值只能从两个状态转移过来：`dp[i-1][j-nums[i-1]]` 与 `dp[i-1][j+nums[i-1]]` 。从前一个数加上第 `i` 个数与从后一个数减去第 `i` 个数

这道题的关键点在于：`j-nums[i-1]` 可以是负数，但我们数组是不允许访问负数的

答案很简单，我们做一个偏移即可，那么这个偏移量的大小是什么

我们看一种最极限的情况，就是 `nums` 数组当中所有值相加恰好等于 `target` 的情况

在这种情况下，我们的偏移量至少是 `nums` 数组当中所有元素的绝对值之和

而对于其他情况，我们可以明确的是 ，我们让 `nums` 数组当中所有数按照上面的方式进行加和，就一定不会出现问题

偏移量绝对不是 `2 * target` 

具体看下面代码：

```cpp
class Solution {
public:
	int findTargetSumWays(vector<int>& nums, int target)
	{
		int n = nums.size();
		int sum = 0;
		for (int i : nums)
			sum += abs(i);
        if(sum < abs(target))
            return 0;
		vector<vector<int>>dp(n + 1, vector<int>(2 * sum + 1, 0));
		dp[0][sum] = 1;
		for (int i = 1; i <= n; i++)
		{
			for (int j = -sum; j <= sum; j++)
			{
				if (j - nums[i - 1] + sum >= 0)
					dp[i][j + sum] += dp[i - 1][j - nums[i - 1] + sum];
				if (j + nums[i - 1] + sum <= 2 * sum)
					dp[i][j + sum] += dp[i - 1][j + nums[i - 1] + sum];
			}
		}
		return dp[n][sum + target]; 
	}
};
```

