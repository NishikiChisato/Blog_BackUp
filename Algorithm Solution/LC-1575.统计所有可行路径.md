---
title: LC 1575.统计所有可行路径
tags: [路径问题, 动态规划, DFS, 记忆化搜索, 模板]
categories: Algorithm Solution
---

#### [1575. 统计所有可行路径](https://leetcode.cn/problems/count-all-possible-routes/)

给你一个 **互不相同** 的整数数组，其中 `locations[i]` 表示第 `i` 个城市的位置。同时给你 `start`，`finish` 和 `fuel` 分别表示出发城市、目的地城市和你初始拥有的汽油总量

每一步中，如果你在城市 `i` ，你可以选择任意一个城市 `j` ，满足  `j != i` 且 `0 <= j < locations.length` ，并移动到城市 `j` 。从城市 `i` 移动到 `j` 消耗的汽油量为 `|locations[i] - locations[j]|`，`|x|` 表示 `x` 的绝对值。

请注意， `fuel` 任何时刻都 **不能** 为负，且你 **可以** 经过任意城市超过一次（包括 `start` 和 `finish` ）。

请你返回从 `start` 到 `finish` 所有可能路径的数目。

由于答案可能很大， 请将它对 `10^9 + 7` 取余后返回。

```
输入：locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5
输出：4
解释：以下为所有可能路径，每一条都用了 5 单位的汽油：
1 -> 3
1 -> 2 -> 3
1 -> 4 -> 3
1 -> 4 -> 2 -> 3
```

​	 

#### DFS + 记忆化搜索

我们先讨论一下什么时候会用到 DFS 

DFS ，也就是暴力搜索，通过**以 `n` 叉树的形式**将所有可能出现的情况全部列举出来（必然会有重复），进而得到最终的答案

既然涉及到 `n` 叉树，那就肯定会涉及到递归与循环

因此，DFS 有两个特定：

* 由于使用递归加循环，因此可以暴力穷举出**仅仅通过嵌套 `for` 循环无法实现的穷举**
* 在不剪枝的情况下，时间复杂度为**指数级**（一般来讲是 `n` 叉数，高度为 `m`）

所有，在不进行剪枝的情况下，使用 DFS 的数据量级**不能超过 30**

对 DFS 进行剪枝的操作，叫做「记忆化搜索」，也就是我们之前一直使用的「备忘录」

回到这道题，我们需要给出所有从 `start` 到 `finish` 的路径

我们从起点开始考虑这个问题。假设我当前处于 `start` 处，我有 `n-1` 种选择去走下一步（姑且不考虑油量的问题）

当我走下一步之后，又会有 `n-1` 种选择（因为一个点可以多次到达）

所以我们可以确定一点：这道题很难通过嵌套 `for` 循环得到最终的结果，也就是说，我们需要想到用 DFS 来暴力枚举所有可能

即 DFS 函数的返回值就是**当前位置到终点的所有路径和**

​	 

关于 DFS 的实现，我们需要注意以下三个问题：

* 确定「参数」的含义
* 确定递归函数的出口（也就是 Base Case）

* 编写「最小递归单元」的处理逻辑

我们先看第一个，容易发现，我们每次移动的时候会发生改变的位置有两个，一个是当前位置 `pos` ，另一个是当前油量 `fuel` 

显然，这两个就需要加入到参数部分

除此之外，我们还需要确定是否到达终点 `end` 以及输入数组 `lc` （location）

接着我们看递归的出口部分，也就是去找 Base Case

在这个部分，我们需要确定的是：**什么情况下，此次递归是有效或者无效的**

有效的情况非常简单，只要当前位置 `pos` 到达 `end` ，我们就让路径数加 1

无效的情况稍微复杂一点

一个很容易想到的是，当前油量 `fuel` 为负数，直接返回 0

还有一个是，当前油量 `fuel` 不为负数，但无法去到任何地方，这个也需要返回 0

至于「最小递归单元」的处理问题，由于我们是需要对**当前位置以外的所有位置进行遍历**，因此我们将遍历得到的结果求和返回即可

​	 

然后，我们来看看「记忆化搜索」的部分

从上面的分析当中得知，我们目前有两个量（`pos` 和 `fuel`）是会发生改变的

而我们 DFS 函数的返回值的意义为：从当前位置出发到达终点的所有路径和

因此我们设置一共缓存数组 `cache` ，其定义为：从当前位置 `pos` 在拥有油量为 `fuel` 的情况下到达终点的所有路径和为 `cache[pos][fuel]` 

​	 

总体代码如下：

```cpp
class Solution {
public:
	vector<vector<int>>cache;//处于pos位置且油量为fuel, 到达end的路径数
	int mod = 1000000007;

	int dfs(vector<int>& lc, int pos, int end, int fuel)//pos fuel 为当前位置与油量, end 为终点
	{
		if (cache[pos][fuel] != -1)
			return cache[pos][fuel];
		if (pos != end && fuel < 0)
		{
			cache[pos][fuel] = 0;
			return 0;
		}

		int n = lc.size();
		bool gonext = false;
		for(int i = 0; i < n; i++)
			if (i != pos)
			{
				int need = abs(lc[i] - lc[pos]);
				if (fuel >= need)
				{
					gonext = true;
					break;
				}
			}
		if (fuel > 0 && !gonext)
		{
			cache[pos][fuel] = pos == end ? 1 : 0;
			return cache[pos][fuel];
		}

		int sum = pos == end ? 1 : 0;//如果当前就是end, 那么我们需要返回1
		
		for (int i = 0; i < n; i++)
		{
			if (pos != i)
			{
				int need = abs(lc[i] - lc[pos]);
				if (fuel >= need)
				{
					sum += dfs(lc, i, end, fuel - need);
					sum %= mod;
				}
			}
		}
		cache[pos][fuel] = sum;
		return sum;
	}

	int countRoutes(vector<int>& locations, int start, int finish, int fuel)
	{
		int n = locations.size();
		cache.assign(n, vector<int>(fuel + 1, -1));
		return dfs(locations, start, finish, fuel);
	}
};
```

时间复杂度：$O(n^2*fuel)$  ，最坏的情况下，我们有 $n*fuel$ 个状态需要去遍历（填满 $fuel$ 数组），对每个状态而言又需要去遍历一次 $locations$ 数组

空间复杂度：$O(n^2*fuel)$ ，由于是树型结构，因此有多少个状态就需要多少的空间

​	 

#### DFS + 记忆化搜索（Base Case 优化）

这里是可以在 Base Case 的部分进行优化的

思考一个问题：如果下一步无法到达终点，还有机会到达吗

假设当前油量为 $fuel$ ，到达终点所需油量为两地位置差的绝对值，即： $need=|lc[end]-lc[pos]|$ 

此时有 $fuel<need$ 

当我每次移动到一个新位置时，所花费油量均有 $cost>0$ 

因此到达新位置的油量为 $fuel'=fuel-cost<fuel$ ，此时到达终点所需油量为 $need'=lc[end]-lc[new]=need-cost$ （题目当中有说任意两个地点的值不相同） 

即：$\Delta fuel = \Delta need$ ，也就是说，只要当前位置无法一步到达终点，走其他路也无法到达

完整代码如下：

​	 

```cpp
class Solution {
public:
	vector<vector<int>>cache;//处于pos位置且油量为fuel, 到达end的路径数
	int mod = 1000000007;

	int dfs(vector<int>& lc, int pos, int end, int fuel)//pos fuel 为当前位置与油量, end 为终点
	{
		if (cache[pos][fuel] != -1)
			return cache[pos][fuel];

		int n = lc.size();

		int need = abs(lc[pos] - lc[end]);//改动在这里
		if (fuel < need)
		{
			cache[pos][fuel] = 0;
			return 0;
		}

		int sum = pos == end ? 1 : 0;
		
		for (int i = 0; i < n; i++)
		{
			if (pos != i)
			{
				int need = abs(lc[i] - lc[pos]);
				if (fuel >= need)
				{
					sum += dfs(lc, i, end, fuel - need);
					sum %= mod;
				}
			}
		}
		cache[pos][fuel] = sum;
		return sum;
	}

	int countRoutes(vector<int>& locations, int start, int finish, int fuel)
	{
		int n = locations.size();
		cache.assign(n, vector<int>(fuel + 1, -1));
		return dfs(locations, start, finish, fuel);
	}
};
```

时空复杂度与上面一致

​	 

#### DP 数组

其实上面记忆化搜索的模块是为了引出下面这个用 `DP` 数组实现的方案

这道题就属于路径规划里面那种没办法直接猜出 `DP` 数组的定义的情况

毕竟这玩意的定义，全靠经验

而算法题是，只要这道题我没做过类似的题目，那么我大概率这道题做不出来

所有，我们需要一种可以得到 `DP` 数组定义的方法，这个方法就是记忆化搜索

当然，用 `DP` 数组可以解的题目，记忆化搜索都可以解

我们不是说去用记忆化搜索去解题（用也没关系啦），而是借用这种思考方式来引出 `DP` 数组的定义

根据上面的分析，我们目前手里有两个变量：当前位置 $pos$ 和剩余油量 $fuel$ ，那么我们可以仿照上面 `dfs` 函数的定义，来写一个 `DP` 数组的定义

当前位置为 `pos` 且剩余油量为 `fuel` 时，到达终点的所有路径和为 `dp[pos][fuel]` 

然后，对于当前位置 `pos` 而言，我们需要去遍历剩下的 `n-1` 个位置

并且有一点需要注意的是，在我还没有去遍历的时候，我的初始油量都是 `fuel` 

这里就类似于 `dfs` 函数里面的 `for` 循环，每次进入递归的时候，`fuel` 都是不变的，改变的是 `need` 

因此，我们在遍历这个二维数组的时候，需要将**第二维的遍历放在外层循环**

然后便是 Base Case 的处理，这里我们需要处理的只有一种情况，就是只要当前处于 `finish` ，不管当前油量是多少，将数组全部初始化为 1 ，即 `dp[finish][j] = 1` 

完整代码如下：

```cpp
class Solution {
public:
	int mod = 1000000007;
	int countRoutes(vector<int>& locations, int start, int finish, int fuel)
	{
		int n = locations.size();
		vector<vector<int>>dp(n, vector<int>(fuel + 1, 0));
		for (int j = 0; j < fuel + 1; j++)
			dp[finish][j] = 1;
		for (int cur = 0; cur < fuel + 1; cur++)
		{
			for (int i = 0; i < n; i++)
			{
				for (int k = 0; k < n; k++)
				{
					if (k == i)
						continue;
					int need = abs(locations[i] - locations[k]);
					if (cur >= need)
					{
						dp[i][cur] += dp[k][cur - need];
						dp[i][cur] %= mod;
					}
				}
			}
		}
		return dp[start][fuel];
	}
};
```

时空复杂度并不会发生变化

​	 

#### 总结

对于那种没有做过的路径问题，我们可以先尝试着去想想对应的记忆化搜索要怎么处理，然后便可以很容易的照搬得出出 `dp` 的定义了