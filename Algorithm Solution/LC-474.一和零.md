---
title: LC 474.一和零
tags: [动态规划, 背包]
categories: Algorithm Solution
---

#### [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```



#### 朴素三维 DP

这道题是一个多维背包的问题

做多了会有这种感觉：题目叫我们求最大值，一般都会往动态规划那个方向去靠

这道题里面，变量有三个：可选择的字符串，0 的个数，1 的个数

我们定义 `dp[i][j][k]` 为：考虑前 `i` 个字符串，在 0 的个数为 `j` ，1 的个数为 `k` 的情况下的最大子集的长度

 我们用一个 `cnt` 数组来额外记录原数组当中每个字符串当中 0 和 1 的数量

那么显然：
$$
dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-cnt[i-1][0]][k-cnt[i-1][1]])
$$
代码如下：

```cpp
class Solution {
public:
	int findMaxForm(vector<string>& strs, int m, int n)
	{
		vector<vector<int>>cnt;
		for (int i = 0; i < strs.size(); i++)
		{
			int zero = 0, one = 0;
			string str = strs[i];
			for (int i = 0; i < str.length(); i++)
			{
				if (str[i] == '0')
					zero++;
				else one++;
			}
			cnt.push_back({ zero, one });
		}
		int len = strs.size();
		vector<vector<vector<int>>>dp(len + 1, vector<vector<int>>(m + 1, vector<int>(n + 1, 0)));
		for (int i = 1; i <= len; i++)
		{
			int zero = cnt[i - 1][0], one = cnt[i - 1][1];
			for (int j = 0; j <= m; j++)
			{
				for (int k = 0; k <= n; k++)
				{
					int x = dp[i - 1][j][k];
					int y = (j >= zero && k >= one) ? dp[i - 1][j - zero][k - one] + 1 : 0;
					dp[i][j][k] = max(x, y);
				}
			}
		}
		return dp[len][m][n];
	}
};
```

时间复杂度：$O(n^3)$ 

空间复杂度：$O(n^3)$ 



#### 二维空间压缩

我们从后往前遍历，虽然有两层循环，但不影响，统一从后往前

这个不难，直接给代码

```cpp
class Solution {
public:
	int findMaxForm(const vector<string>& strs, int m, int n)
	{
		vector<vector<int>>cnt;
		for (int i = 0; i < strs.size(); i++)
		{
			int zero = 0, one = 0;
			string str = strs[i];
			for (int i = 0; i < str.length(); i++)
			{
				if (str[i] == '0')
					zero++;
				else one++;
			}
			cnt.push_back({ zero, one });
		}
		int len = strs.size();
		vector<vector<int>>dp(m + 1, vector<int>(n + 1, 0));
		for (int i = 1; i <= len; i++)
		{
			for (int j = m; j >= 0; j--)
			{
				for (int k = n; k >= 0; k--)
				{
					int zero = cnt[i - 1][0], one = cnt[i - 1][1];
					int x = dp[j][k];
					int y = (j >= zero && k >= one) ? dp[j - zero][k - one] + 1 : 0;
					dp[j][k] = max(x, y);
				}
			}
		}
		return dp[m][n];
	}
};
```

时间复杂度：$O(n^3)$ 

空间复杂度：$O(n^2)$ 



#### 最后

需要说明的是，我们在遍历 `dp` 数组的时候，是「按需遍历」

意思是指，只有这个值是有意义的，我才遍历

用第一个三维的来举例就是

显然选择前 0 个并没有什么意义，因此 `i` 从 1 开始遍历

除此之外，这里也没有涉及到 Base Case 的情况，所以不需要对数组进行初始化

对于内层的 `j` 和 `k` ，由于不会有空串的出现，因此二者均从 1 开始遍历

当然，`j` 需要遍历 `m` 次，`k` 需要遍历 `n` 次