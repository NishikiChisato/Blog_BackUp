---
title: LC 2406.将区间分为最少组数
tags: [贪心, 数组, 前缀和, 堆(优先队列), 残留]
categories: Algorithm Solution
---

#### [2406. 将区间分为最少组数](https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/)

给你一个二维整数数组 `intervals` ，其中 `intervals[i] = [lefti, righti]` 表示 **闭** 区间 `[lefti, righti]` 。

你需要将 `intervals` 划分为一个或者多个区间 **组** ，每个区间 **只** 属于一个组，且同一个组中任意两个区间 **不相交** 。

请你返回 **最少** 需要划分成多少个组。

如果两个区间覆盖的范围有重叠（即至少有一个公共数字），那么我们称这两个区间是 **相交** 的。比方说区间 `[1, 5]` 和 `[5, 8]` 相交。

```
输入：intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]]
输出：3
解释：我们可以将区间划分为如下的区间组：
- 第 1 组：[1, 5] ，[6, 8] 。
- 第 2 组：[2, 3] ，[5, 10] 。
- 第 3 组：[1, 10] 。
可以证明无法将区间划分为少于 3 个组。
```

​	 

#### 贪心 + 优先队列

首先，在对区间进行分组时，我们需要按照**顺序**来进行讨论是否要将一个新的区间加入当前已有的组还是另开一个新组

由于本题的输入与最终的分组**无关**，因此可以将所有的数组按照**首元素**进行**排序**

由于需要将区间加入到某个组，因此需要从区间的角度来考虑问题

状态一：我们遍历到第一个区间，把它单独作为一个组

状态二：遍历到第二个区间，这里分两种情况

* 如果第二个区间的左端点**大于**第一个区间的右端点，由于我们期望总的组数是**最少**的，因此需要将第二个区间加入到第一个区间所在的组，那么在遍历下一个区间的时候，将回到**状态一**的情况
  * 进一步，如果存在多个组，我们需要将当前遍历到的区间加入到右端点**最小**的区间所在的组
* 如果第二个区间的左端点**小于**第一个区间的右端点，那么只能另开一组

由于我们需要快速求出最小区间右端点，因此这里我们需要小根堆这个数据结构

在先前的排序中，我们已经对区间的左端点排好序了，因此后遍历的区间的左端点一定大于先遍历的区间的左端点，因此关于左端点的讨论可以忽略

具体地，我们用堆来维护某个组的区间右端点的大小，当遍历到某个区间时，如果该区间的左端点小于最小的右端点，那么就需要新开一组（`push`） ，如果没有，那么将它加入到最小区间右端点所在的组（先 `pop` 后 `push` ）

```cpp
class Solution {
public:
	int minGroups(vector<vector<int>>& intervals)
	{
		sort(intervals.begin(), intervals.end(), [](auto& a, auto& b) {return a[0] < b[0]; });
		priority_queue<int, vector<int>, greater<int>>heap;
		for (int i = 0; i < intervals.size(); i++)
		{
			if (!heap.empty() && intervals[i][0] > heap.top())
			{
				heap.pop();
				heap.push(intervals[i][1]);
			}
			else heap.push(intervals[i][1]);
		}
		return heap.size();
	}
};
```

时间复杂度：$O(nlogn)$ 

空间复杂度：$O(n)$

