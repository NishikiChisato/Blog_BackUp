---
title: 动规 多重背包问题
tags: [背包, 动态规划]
categories: Algorithm Solution
---

### 多重背包

问题描述：

有 `N` 种物品和一个最多能背重量为 `W` 的背包。第 `i` 件物品的重量是 `w[i]` ，得到的价值是 `v[i]` ，**可以选择的次数是 `s[i]`** 

求解将哪些物品装入背包里使得物品价值总和最大



我们看到， 0-1 背包是每件物品**只能选择一次**，完全背包是每一件物品可以**选择无数次**，而多重背包是每一件物品可以**选择有限次**

这三者的区别也就在对物品的选择次数上面了，直接套用前面的定义，我们给出 `dp` 数组的定义：

`dp[i][j]` 表示考虑前 `i` 个物品，在背包容量不超过 `j` 的情况下所得到的最大价值

不失一般性地，我们考虑对第 `i` 件物品进行选择（`i` 从 1 开始遍历）

选择 0 次第 `i` 件物品，有：$dp[i][j]=dp[i-1][j]$

选择 1 次第 `i` 件物品，有：$dp[i][j]=dp[i-1][j-w[i-1]]+v[i-1]$

选择 2 次第 `i` 件物品，有：$dp[i][j]=dp[i-1][j-2*w[i-1]]+2*v[i-1]$ 

$\cdots$

选择 $s[i-1]$ 次第 `i` 件物品，有：$dp[i][j]=dp[i-1][j-s[i-1]*w[i-1]]+s[i-1]*v[i-1]$ 

因此状态转移方程为：

$dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*w[i-1]]+k*v[i-1])$ 其中 $0\le k \le s[i-1],\ 0\le k*w[i-1]\le j$ 

下面给出完整代码：

```cpp
int back(int N, int W, vector<int>& v, vector<int>& w, vector<int>& s)
{
    vector<vector<int>>dp(N + 1, vector<int>(W + 1, 0));
    for (int j = 0; j <= W; j++)
    {
        int maxselect = min(j / w[j], s[j]);
        dp[0][j] = maxselect * v[j];
    }

    for (int i = 1; i <= N; i++)
    {
        for (int j = 0; j <= W; j++)
        {
            int x = dp[i - 1][j];//不选择物品
            int y = 0;
            for (int k = 1; k <= s[i]; k++)
            {
                if (j < k * s[i - 1])
                    break;
                y = max(y, dp[i - 1][j - k * s[i - 1]] + k * v[i - 1]);
            }
            dp[i][j] = max(x, y);
        }
    }
    return dp[N][W];
}
```

时间复杂度：$O(n^3)$ 

空间复杂度：$O(n^2)$ 



### 一维空间优化

```cpp
int back(int N, int W, vector<int>& v, vector<int>& w, vector<int>& s)
{
    vector<int>dp(W + 1, 0);
    for (int i = 0; i <= N; i++)
        for (int j = W; j >= w[i]; j--)
            for (int k = 1; k <= s[i] && j >= k * w[i]; k++)
                dp[j] = max(dp[j], dp[j - k * w[i]] + k * v[i]);
    return dp[W];
}
```

时间复杂度：$O(n^3)$ 

空间复杂度：$O(n)$ 

对于多重背包而言，时间复杂度是无法降下来的。也就是说，如果数据量超过 $10^2$ ，就会超时



### 二进制优化

由于多重背包当中的每个物品是有数量的（在背包容量允许的情况下），因此我们可以将所有的物品全部列举出来，将其转换成 0-1 背包来进行处理

但我们只需要稍微想一想就能发现，这种方式在时间复杂度上不会有任何的优化，而且空间复杂度还增大了

因为 `dp` 的状态一共有 $n^2$ 个，并且我还需要去对于每个物品我还需要去遍历 $s[i]$ ，因此在时间复杂度上是没有变化的

空间复杂度就很简单了，需要一个更大的数组来装这么多数嘛

在我们不改变 `dp` 数组的定义的时候，唯一可以优化的地方是减少对每个数的遍历次数

原先需要对某个数遍历 $n$ 次，现在如果我只需要遍历 $log\ n$ 次就能解决，那么总时间复杂度就能从 $n^3$ 降为 $n^2log\ n$ 

具体的，对于第 `i` 个数，我最大可以选择 $s[i]$ 次，那么我需要对这 $s[i]$ 个数逐个遍历一遍才能得到最终结果

现在，如果我们想要用遍历 $log\ s[i]$ 就能解决问题的话，我们就必须用这 $log\ s[i]$ 个数的组合来表示出所有 $s[i]$ 的数

举个例子，假如 $s[i]=10$ ，也就是说 $k$ 需要从 1 开始遍历到 10

但对于 10 这个数，我们可以用 1、2、4、3 这四个数的组合来表示出所有 1 到 10 的数

前面的 1、2、4 ，是需要以 2 的倍数进行增长。后面的 3 是余数，可以通过 10 - 1 - 2 - 4 得到

这样，我们便可以用 $log\ s[i]$ 个数来表示 $s[i]$ 了

需要注意的是，$v[i]$ 与 $w[i]$ 也需要同步进行增大，处理完只后就完全是 0 -1 背包了

完整代码如下：

```cpp
int back(int N, int W, vector<int>& v, vector<int>& w, vector<int>& s)
{
    vector<int>value;
    vector<int>weight;
    for (int i = 0; i < N; i++)
    {
        int val = s[i];
        for (int k = 1; k < val; k *= 2)
        {
            val -= k;
            value.push_back(k * v[i]);
            weight.push_back(k * w[i]);
        }
        if (val > 0)//对余下的数进行处理
        {
            value.push_back(val * v[i]);
            weight.push_back(val * w[i]);
        }
    }
    vector<int>dp(W + 1, 0);//转 0-1 背包
    for (int i = 0; i <= N; i++)
        for (int j = W; j >= weight[i]; j--)
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    return dp[W];
}
```

时间复杂度：$O(n^2*logn)$ 

空间复杂度：$O(n)$ 

该算法适用于数据量为 $10^3$ 的情况