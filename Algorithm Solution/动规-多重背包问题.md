---
title: 动规 多重背包问题
tags: [背包, 动态规划]
categories: Algorithm Solution
---

### 多重背包

问题描述：

有 `N` 种物品和一个最多能背重量为 `W` 的背包。第 `i` 件物品的重量是 `w[i]` ，得到的价值是 `v[i]` ，**可以选择的次数是 `s[i]`** 

求解将哪些物品装入背包里使得物品价值总和最大



我们看到， 0-1 背包是每件物品**只能选择一次**，完全背包是每一件物品可以**选择无数次**，而多重背包是每一件物品可以**选择有限次**

这三者的区别也就在对物品的选择次数上面了，直接套用前面的定义，我们给出 `dp` 数组的定义：

`dp[i][j]` 表示考虑前 `i` 个物品，在背包容量不超过 `j` 的情况下所得到的最大价值

不失一般性地，我们考虑对第 `i` 件物品进行选择（`i` 从 1 开始遍历）

选择 0 次第 `i` 件物品，有：$dp[i][j]=dp[i-1][j]$

选择 1 次第 `i` 件物品，有：$dp[i][j]=dp[i-1][j-w[i-1]]+v[i-1]$

选择 2 次第 `i` 件物品，有：$dp[i][j]=dp[i-1][j-2*w[i-1]]+2*v[i-1]$ 

$\cdots$

选择 $s[i-1]$ 次第 `i` 件物品，有：$dp[i][j]=dp[i-1][j-s[i-1]*w[i-1]]+s[i-1]*v[i-1]$ 

因此状态转移方程为：

$dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*w[i-1]]+k*v[i-1])$ 其中 $0\le k \le s[i-1],\ 0\le k*w[i-1]\le j$ 

下面给出完整代码：

```cpp
	int back(int N, int W, vector<int>& v, vector<int>& w, vector<int>& s)
	{
		vector<vector<int>>dp(N + 1, vector<int>(W + 1, 0));
		for (int j = 0; j <= W; j++)
		{
			int maxselect = min(j / w[j], s[j]);
			dp[0][j] = maxselect * v[j];
		}

		for (int i = 1; i <= N; i++)
		{
			for (int j = 0; j <= W; j++)
			{
				int x = dp[i - 1][j];//不选择物品
				int y = 0;
				for (int k = 1; k <= s[i]; k++)
				{
					if (j < k * s[i - 1])
						break;
					y = max(y, dp[i - 1][j - k * s[i - 1]] + k * v[i - 1]);
				}
				dp[i][j] = max(x, y);
			}
		}
		return dp[N][W];
	}
```

时间复杂度：$O(n^3)$ 

空间复杂度：$O(n^2)$ 



### 一维空间优化

