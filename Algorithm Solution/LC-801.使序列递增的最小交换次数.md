---
title: LC 801.使序列递增的最小交换次数
tags: [动态规划, 状态机, 数组, 残留]
categories: Algorithm Solution
---

#### [801. 使序列递增的最小交换次数](https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/)

我们有两个长度相等且不为空的整型数组 `nums1` 和 `nums2` 。在一次操作中，我们可以交换 `nums1[i]` 和 `nums2[i]`的元素。

- 例如，如果 `nums1 = [1,2,3,8]` ， `nums2 =[5,6,7,4]` ，你可以交换 `i = 3` 处的元素，得到 `nums1 =[1,2,3,4]` 和 `nums2 =[5,6,7,8]` 。

返回 *使 `nums1` 和 `nums2` **严格递增** 所需操作的最小次数* 。

数组 `arr` **严格递增** 且 `arr[0] < arr[1] < arr[2] < ... < arr[arr.length - 1]` 。

**注意：**

- 用例保证可以实现操作。

 

**示例 1:**

```
输入: nums1 = [1,3,5,4], nums2 = [1,2,3,7]
输出: 1
解释: 
交换 A[3] 和 B[3] 后，两个数组如下:
A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]
两个数组均为严格递增的。
```

**示例 2:**

```
输入: nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9]
输出: 1
```

 

**提示:**

- `2 <= nums1.length <= 105`
- `nums2.length == nums1.length`
- `0 <= nums1[i], nums2[i] <= 2 * 105`

​	 

#### 状态机 DP

在我们原先的一维 `dp[i]` 数组当中，`dp[i]` 表示的是**状态**，`dp[i]` 的值表示的是**该状态对应的数值**

我们看到这里有一个问题是，`dp[i]` 只能表示一个状态，如果我希望增加其表示状态的能力，那么我们可以选择：**扩大维度**

我们通常会用第二个维度来表示**选择**，不同的选择会对应多种不同的状态，这便是**状态机**

基于此原理，我们可以不断扩大原始数组的维度，但核心不好发生改变

我们定义一个二维数组 `dp[i][2]` 表示考虑**下标**范围为 $[0,i]$ 的数，`dp[i][0]` 表示不交换下标为 `i` 的两个数， `dp[i][1]` 表示交换下标为 `i` 的两个数，那么最终的结果就是 $min(dp[i-1][0],dp[i-1][1])$ 

在 `dp` 数组的初始化部分，显然有 `dp[0][0]=0, dp[0][1]=1` ，对于其他值，我们直接**初始化成一个最大值** $INF$ 即可

不失一般性地考虑转移方程：

* 如果 $nums1[i]>nums1[i-1],\ nums2[i]>nums2[i-1]$ ，我们可以交换下标为 `i` 的元素（前者），也可以不交换（后者），即：

$$
dp[i][1]=dp[i-1][1]+1\\
dp[i][0]=dp[i-1][0]
$$

 

需要说明的是，由于我们只能确定单个数组当中的对应关系，因此在交换下标为 `i` 的元素时，下标为 `i - 1` 的元素也需要跟着交换

* 如果 $nums1[i]>nums2[i-1],\ nums2[i]>nums1[i-1]$ ，我们可以选择交换下标为 `i` 的元素（前者），也可以选择交换下标为 `i - 1` 的元素（后者）

$$
dp[i][1]=dp[i-1][0]+1\\
dp[i][0]=dp[i-1][1]
$$

完整代码如下：

```cpp
class Solution {
public:
    const int INF = 1e6;
    int minSwap(vector<int>& nums1, vector<int>& nums2) 
    {
        int n = nums1.size();
        vector<vector<int>>dp(n + 1, vector<int>(2, INF));
        dp[0][0] = 0, dp[0][1] = 1;
        for(int i = 1; i < n; i++)
        {
            if(nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1])
            {
                dp[i][0] = dp[i - 1][0];
                dp[i][1] = dp[i - 1][1] + 1;
            }
            if(nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1])
            {
                dp[i][0] = min(dp[i - 1][1], dp[i][0]);
                dp[i][1] = min(dp[i - 1][0] + 1, dp[i][1]);
            }
        }
        return min(dp[n - 1][0], dp[n - 1][1]);
    }
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(n)$ 

关于这道题的滚动数组优化，我试了一下，发现貌似解决不了，有时间回来再看吧