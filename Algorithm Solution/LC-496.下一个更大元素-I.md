---
title: LC 496.下一个更大元素 I
tags: [单调栈, 哈希表, 数组]
categories: Algorithm Solution
---

#### [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

```
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
```

​	 

#### 单调栈 + 哈希表（从后往前遍历）

对于这种求某个数的「最近一个比其大的元素」或者「最近一个比其小的元素」，都要想到「单调栈」

单调栈，可以理解为通过一种巧妙的方式使得栈中元素具有「单调性」

具体地，如果我需要维护一个单调栈，需要做到下面两点：

* 若当前元素**大于**栈顶元素 `x > stack.top()` ，那么该元素入栈 `stack.push(x)` 
* 若当前元素**小于等于**栈顶元素 `x <= stack.top()` ，那么需要**不断地**让栈顶元素出栈，直到**栈空**或者**出现第一种情况**

明白基本实现后，我们便可以使用单调栈来解决这道题

我们**逆序**遍历 `nums2` ，动态维护一个**单调栈**，考虑当前元素 `nums2[i]` 

* 如果栈为空，那么说明它**右边没有比它大的元素**，我们将该元素入栈

* 如果栈不为空，那么说明栈顶元素就是**最近一个比其大的元素**，之后再将该元素入栈即可


一定要记得，是**先检查后入栈**

上面整个过程，我们可以将值存入哈希表中，这样我们可以直接通过查表得出 `nums1` 各个数对应的下一个最大元素

```cpp
class Solution {
public:
	vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2)
	{
		stack<int>st;
		unordered_map<int, int>mp;
		for (int i = nums2.size() - 1; i >= 0; i--)
		{
			while (!st.empty() && st.top() <= nums2[i])
				st.pop();
			mp.insert(pair<int, int>(nums2[i], st.empty() ? -1 : st.top()));
            st.push(nums2[i]);
		}
		vector<int>ret(nums1.size(), 0);
		for (int i = 0; i < nums1.size(); i++)
			ret[i] = mp[nums1[i]];
		return ret;
	}
};
```

时间复杂度：$O(n+m)$ ，会遍历一次 `nums1` 与 `nums2` 数组，哈希表的插入查找操作的时间复杂度均为 $O(1)$ 

空间复杂度：$O(n)$ ， $n$ 为较长数组的大小

​	 

我们说一下为什么需要从后往前遍历的问题

我们是需要找出某一个数**后面**第一个比它大的数

而我们维护的栈，从底往上看是**单调递增**的

并且我们是从后往前遍历，那么对于 `nums[i]` 而言，栈顶元素一定是距离它最近的并且该元素一定比 `nums[i]` 大

这样就达成了题目所要求的「下一个最大元素」

找到之后，我们**不会**将原栈顶元素弹出，而是将 `nums[i]` 压入栈中，在下一次循环开始的时候再确保栈是单调的

不将原栈顶元素弹出是因为我们需要保存**当前已知的最大元素**

事实上，单调栈可以以另一种方式来理解：

我们不断以单调递增的顺序来保存**当前**已知的最大元素，而栈顶元素就是**「最近」并且「当前最大」**的元素

​	 

#### 单调栈 + 哈希表（从前往后遍历）

从后往前遍历是不断在记录**当前**已知的最大元素，栈是单调递增的过程

这个「当前」，实际上是一个动态的过程

每当我们遇到一个元素，只要栈不为空，那么我们可以肯定的是栈顶元素一定是当前元素的「下一个更大元素」

当然，这个过程我们也可以反过来，即从前往后遍历，只不过这样会稍微麻烦一点

一般地，当前遍历到元素 `nums[i]` ，只要 `nums[i]` 后面的元素都比它小，那么 `nums[i]` 的「下一个更大元素」就是**无法确定的**

这个过程直到我们遍历到一个比 `nums[i]` 还要大的元素 `x` 才会终止，其结果为 `nums[i]` 以及后面比它小的所有元素的「下一个更大元素」都为 `x` 

这个过程，像不像单调栈？

我们维护一个单调递减的栈来实现这个过程

需要注意的是，由于最后一个元素没有下一个元素，因此需要额外处理

```cpp
class Solution {
public:
	vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2)
	{
		unordered_map<int, int>hashmap;
		stack<int>st;
		for (int i = 0; i < nums2.size(); i++)
		{
			while (!st.empty() && st.top() < nums2[i])
			{
				hashmap[st.top()] = nums2[i];
				st.pop();
			}
            if(!st.empty())
                hashmap[st.top()] = -1;
			st.push(nums2[i]);
		}
        if(!st.empty())
            hashmap[st.top()] = -1;
		vector<int>ret(nums1.size());
		for (int i = 0; i < nums1.size(); i++)
		{
			ret[i] = hashmap[nums1[i]];
		}
		return ret;
	}
};
```

时空复杂的同上