---
title: LC 581.最短无序连续子数组
tags: [单调栈, 双指针, 数组]
categories: Algorithm Solution
---

#### [581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)

给你一个整数数组 `nums` ，你需要找出一个 **连续子数组** ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

请你找出符合题意的 **最短** 子数组，并输出它的长度。

```
输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
```

​	 

#### 双指针 + 单调栈

在我们的理解中，单调栈内部的元素是**「当前已知的较小元素」**，但这对单调栈而言只满足单调的特性，不满足栈的特性

如果我们试图将一个部分有序的数组压入到单调栈内部，那么它会**自动弹出这个数组内非递增的元素**，这一性质正好契合我们需要找出数组的无序区间这个需求

具体地，从左向右以单调递增栈扫描数组，不断记录弹出元素的下标并取最小值，这里就是最终无序区间的左端点，右端点的处理同理

```cpp
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) 
    {
        stack<int>stk;
        int l = INT32_MAX, r = INT32_MIN;
        for(int i = 0; i < nums.size(); i++)
        {
            while(!stk.empty() && nums[stk.top()] > nums[i])
            {
                l = min(l, stk.top());
                stk.pop();
            }
            stk.push(i);
        }
        while(!stk.empty())
            stk.pop();
        for(int i = nums.size() - 1; i >= 0; i--)
        {
            while(!stk.empty() && nums[stk.top()] < nums[i])
            {
                r = max(r, stk.top());
                stk.pop();
            }
            stk.push(i);
        }
        return r > l ? r - l + 1 : 0;
    }
};
```

时间复杂度：$O(n)$

空间复杂度：$O(n)$

​	 

#### 优化

我们单就左端点 `l` 来进行考虑

从上面的代码当中可以看到，我们实际上并不需要一直维护一个单调栈的，因为对于区间端点的赋值**仅在当前元素小于目前最大元素**（也就是栈顶元素）

那么我们完全可以从左到右维护一个较大值，只要出现 `nums[i]` 小于这个较大值，我们便记录下标

最后我们发现，这个记录的下标，会不断的向右移动，最终会变为区间的右端点

也就是说，对于右端点的赋值，需要从左往右

完整代码如下：

```cpp
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) 
    {
        int l = INT32_MAX, r = INT32_MIN, n = nums.size();
        int cmax = nums[0], cmin = nums[nums.size() - 1];
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] >= cmax)
                cmax = nums[i];
            else r = max(r, i);
            if(nums[n - 1 - i] <= cmin)
                cmin = nums[n - 1 - i];
            else l = min(l, n - 1 - i);
        }
        return l < r ? r - l + 1 : 0;
    }
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(1)$ 