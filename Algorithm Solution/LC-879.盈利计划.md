---
title: LC 879.盈利计划
tags: [动态规划, 背包]
categories: Algorithm Solution
---

#### [879. 盈利计划](https://leetcode.cn/problems/profitable-schemes/)

集团里有 `n` 名员工，他们可以完成各种各样的工作创造利润。

第 `i` 种工作会产生 `profit[i]` 的利润，它要求 `group[i]` 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。

工作的任何至少产生 `minProfit` 利润的子集称为 **盈利计划** 。并且工作的成员总数最多为 `n` 。

有多少种计划可以选择？因为答案很大，所以 **返回结果模** `10^9 + 7` **的值**。

```
输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]
输出：2
解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。
总的来说，有两种计划。
```



#### 三维 DP

这里问的是有多少种**可能的计划**，基本上就是明说要用 DP 了

我们来看看这里的「变量」有哪些？

所谓「变量」，指的是会影响**「可能计划」**的选择

显然，考虑工作的个数一定是一个

当然，还有参与成员个数以及产生的利润

由于需要产生超过 `minProfit` 的才能称为盈利计划，因此我们可以这么定义：

考虑前 `i` 个工作，在使用员工数为 `j` ，至少盈利 `k` 的情况下所有可能的选择个数为 `dp[i][j][k]` 

显然，当我们不选择第 `i` 个工作时，有
$$
dp[i][j][k]=dp[i-1][j][k]
$$
当我们选择第 `i` 个工作时，有：
$$
dp[i][j][k]=dp[i-1][j-group[i-1]][k-profit[i-1]]
$$
我们回顾 `dp` 数组的定义，对于员工数，是不允许出现负数的。但对于至少盈利数 `k` 而言，并没有规定其不能为负

也就是说，`k` 的值是允许为负数的

这里就有一个问题是，我们的 `k` 一般会从 0 开始遍历，**我们不会遍历负数那一边**

与此同时，就算我们真的想去遍历负数那一边，我们会发现一个问题是：**每个工作产生的利润一定是非负数**，也就是说，直接去遍历是没有意义的

那么该怎么办？

我们考虑为什么 `k - profit[i-1]` 会等于负数

我们 `dp` 数组的定义是至少在盈利为 `k` 时，怎么怎么样

如果 `k - profit[i-1]` 为负数的话，等同于至少盈利为负数的情况下，怎么怎么样

但由于我们每个工作的利润一定是一个非负数，不可能出现负数

这就说明，在到达该状态之前，我们一定没有做任何工作，不然不可能出现至少利润为负数的情况

没有做任何工作，也就相当于是**当前利润至少为 0**

所以，我们可以将这个负数与 0 做一个等价映射，即：
$$
dp[i][j][k]=dp[i-1][j-group[i-1]][max(k-profit[i-1],0)]
$$
完整代码如下：

```cpp
class Solution {
public:
	int mod = 1e9 + 7;

	int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit)
	{
		int m = group.size();
		vector<vector<vector<int>>>dp(m + 1, vector<vector<int>>(n + 1, vector<int>(minProfit + 1, 0)));
		for (int j = 0; j <= n; j++)
			dp[0][j][0] = 1;
		for (int i = 1; i <= m; i++)
		{
			for (int j = 0; j <= n; j++)
			{
				for (int k = 0; k <= minProfit; k++)
				{
					int x = dp[i - 1][j][k];
					int y = (j >= group[i - 1]) ? dp[i - 1][j - group[i - 1]][max(k - profit[i - 1], 0)] : 0;
					dp[i][j][k] = (x + y + dp[i][j][k]) % mod;
				}
			}
		}
		return dp[m][n][minProfit];
	}
};
```

时间复杂度：$O(n^3)$ 

空间复杂度：$O(n^3)$ 



#### 二维空间压缩

我们从后往前遍历，便可以实现空间的压缩

```cpp
class Solution {
public:
	int mod = 1e9 + 7;

	int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit)
	{
		int m = group.size();
		vector<vector<int>>dp(n + 1, vector<int>(minProfit + 1, 0));
		for (int i = 0; i <= n; i++)
			dp[i][0] = 1;
		for (int i = 1; i <= m; i++)
		{
			for (int j = n; j >= group[i - 1]; j--)
			{
				for (int k = minProfit; k >= 0; k--)
				{
					int x = dp[j][k];
					int y = dp[j - group[i - 1]][max(k - profit[i - 1], 0)];
					dp[j][k] = (x + y) % mod;
				}
			}
		}
		return dp[n][minProfit];
	}
};
```

时间复杂度：$O(n^3)$ 

空间复杂度：$O(n^2)$ 