---
title: LC 2420.找到所有好下标
tags: [动态规划]
categories: Algorithm Solution
---

#### [2420. 找到所有好下标](https://leetcode.cn/problems/find-all-good-indices/)

给你一个大小为 `n` 下标从 **0** 开始的整数数组 `nums` 和一个正整数 `k` 。

对于 `k <= i < n - k` 之间的一个下标 `i` ，如果它满足以下条件，我们就称它为一个 **好** 下标：

- 下标 `i` **之前** 的 `k` 个元素是 **非递增的** 。
- 下标 `i` **之后** 的 `k` 个元素是 **非递减的** 。

按 **升序** 返回所有好下标。

```
输入：nums = [2,1,1,1,3,4,1], k = 2
输出：[2,3]
解释：数组中有两个好下标：
- 下标 2 。子数组 [2,1] 是非递增的，子数组 [1,3] 是非递减的。
- 下标 3 。子数组 [1,1] 是非递增的，子数组 [3,4] 是非递减的。
注意，下标 4 不是好下标，因为 [4,1] 不是非递减的。
```

​	 

#### DP

显然，我们需要求出 `i` 前面的递减子数组的长度以及 `i` 后面的递增子数组的长度

是不是跟 LCS 很像？

我们定义两个数组 `f` 和 `g` ，分别用来表示以 `nums[i]` 为结尾的最长递减子数组和最长递增子数组

对于任意的 `i` ，只要 `f[i-1] >= k && g[i+1] >= k` ，这个 `i` 就是满足条件的

我们已 `f` 为例，`g` 的分析思路一致

对于下标 `i` ，如果 `nums[i] <= nums[i-1]` ，那么需要将 `nums[i]` 加入到已知的最长子数组当中，即 `f[i] = f[i-1] + 1` 

如果 `nums[i] > nums[i-1]` ，那么说明当前数不能加入到已知的最长子数组当中，需要另开一个数组，即 `f[i] = 1` 

在初始化部分，我们可以直接把数组当中的每个数全部初始化为 1 ，这样相对简便

代码如下：

```cpp
class Solution {
public:
    vector<int> goodIndices(vector<int>& nums, int k) 
    {
        int n = nums.size();
        vector<int>f(nums.size(), 1), g(nums.size(), 1);
        for(int i = 1; i < nums.size(); i++)
        {
            if(nums[i] <= nums[i - 1])
                f[i] = f[i - 1] + 1;
            if(nums[n - 1 - i] <= nums[n - i])
                g[n - 1 - i] = g[n - i] + 1;
        }
        vector<int>ret;
        for(int i = k; i < nums.size() - k; i++)
        {
            if(f[i - 1] >= k && g[i + 1] >= k)
                ret.push_back(i);
        }
        return ret;
    }
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(n)$ 

