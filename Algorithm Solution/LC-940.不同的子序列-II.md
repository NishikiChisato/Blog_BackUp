---
title: LC 940.不同的子序列 II
tags: [序列 DP, 动态规划]
categories: Algorithm Solution 
---

#### [940. 不同的子序列 II](https://leetcode.cn/problems/distinct-subsequences-ii/)

给定一个字符串 `s`，计算 `s` 的 **不同非空子序列** 的个数。因为结果可能很大，所以返回答案需要对 **`10^9 + 7` 取余** 。

字符串的 **子序列** 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。

- 例如，`"ace"` 是 `"***a***b***c***d***e***"` 的一个子序列，但 `"aec"` 不是。

 

**示例 1：**

```
输入：s = "abc"
输出：7
解释：7 个不同的子序列分别是 "a", "b", "c", "ab", "ac", "bc", 以及 "abc"。
```

**示例 2：**

```
输入：s = "aba"
输出：6
解释：6 个不同的子序列分别是 "a", "b", "ab", "ba", "aa" 以及 "aba"。
```

**示例 3：**

```
输入：s = "aaa"
输出：3
解释：3 个不同的子序列分别是 "a", "aa" 以及 "aaa"。
```

 

**提示：**

- `1 <= s.length <= 2000`
- `s` 仅由小写英文字母组成

​	 

#### 序列 DP

我们定义 $dp[i][j]$ 表示考虑前 $i$ 个字符，以字符 $j$ 为结尾的子序列个数

那么往后便是基本的背包问题

* 若 `s[i] != j` ，说明**当前字符作为结尾是不符合题意的**，也就是对前 $i$ 个字符考虑的结果等于对前 $i-1$ 个字符考虑的结果相同，即： 

$$
dp[i][j] = dp[i-1][j]
$$

* 若 `s[i] == j` ，说明我们以当前字符作为字符串的结尾，那么在前一个字符的选择上，我们有两种可能：
  * 若前一个字符为空，那么它的值直接就是 1
  * 若前一个字符非空，那么它的取值可以是从 'a' 到 'z' 的任意一个
* 将上面两种情况相加，便是这在情况的值，即：

$$
dp[i][j]=1+\sum_{k=0}^{25}dp[i-1][k]
$$

最终，我们将所有 $dp[n][k]$ 的值全部加起来就行

完整代码如下：

```cpp
class Solution {
public:

    int mod = 1e9 + 7;

    int distinctSubseqII(string s) 
    {
        int len = s.length();
        vector<vector<int>>dp(len + 1, vector<int>(26, 0));
        for(int i = 1; i <= len; i++)
        {
            for(int j = 0; j < 26; j++)
            {
                if(j != s[i - 1] - 'a')
                    dp[i][j] = dp[i - 1][j];
                else
                {
                    int cur = 0;
                    for(int k = 0; k < 26; k++)
                        cur = (cur + dp[i - 1][k]) % mod;
                    dp[i][j] = 1 + cur;
                }
            }
        }
        int ans = 0;
        for(int i = 0; i < 26; i++)
            ans = (dp[len][i] + ans) % mod;
        return ans;
    }
};
```

时间复杂度：$O(n^2C)$ ，$C$ 为字符集长度，这里为 26

空间复杂度：$O(nC)$ ，$C$ 为字符集长度

​	 

#### 优化

我们知道，对于这种二维 DP ，我们都可以将空间复杂度从 $O(n^2)$ 降为 $O(n)$ ，但时间复杂度不变

仔细观察不难发现，当 `j ` 等于 `s` 当中的某一个字符时，我们对 `dp[i]j[j]` 的赋值是**通过累加前一行的所有值**得到的

并且，在最终结果也为最后一行的所有值的累加

那么我们便可以直接维护一个 26 长度的字符数组 `dp` ，和一个用于记录**当前所有子序列个数**的变量 `ans` （相当于前一行的所有值的总和）

那么我们只需要遍历 `s` ，对 `dp` 数组的赋值每次都是 `1 + ans` ，`ans` 的更新只需要每次都加上 `dp` 数组对应值的**变化量**即可

最后小心不要超出 int 的范围即可

完整代码如下：

```cpp
class Solution {
public:

    int mod = 1e9 + 7;

    int distinctSubseqII(string s) 
    {
        int len = s.length();
        vector<int>dp(26, 0);
        int ans = 0;
        for(int i = 0; i < len; i++)
        {
            int c = s[i] - 'a';
            int pre = dp[c];
            dp[c] = (1 + ans) % mod;
            ans = ((ans + dp[c]) % mod - pre + mod) % mod;
        }
        return ans;
    }
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(C)$ 
