---
title: LC 84.柱状图中最大的矩形
tags: [单调栈, 数组]
categories: Algorithm Solution
---

#### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

​	 

#### 单调栈 + 贪心思想

这道题其实跟我们之前做过的 [子数组的最小值之和](https://nishikichisato.github.io/2022/09/27/Algorithm Solution/LC-907.子数组的最小值之和/#单调栈-dp) 如出一辙

为了方便，我们用 `hi[i]` 替换掉 `height[i]` 

假定我们遍历到一个矩形 `hi[i]` ，如果我希望由它构成的矩形面积尽可能大，那么左右边界在向两边扩展的时候如果满足 $hi[l]>=hi[i];\ hi[r]>=hi[i],\ 其中\ l<=i,\ r>=i$ ，那么我们便可以构造出一个尽可能大的矩形

其中 `l` 和 `r` 的处理逻辑跟上面的一致，采用单调栈

完整代码如下：

```cpp
class Solution {
public:
	int largestRectangleArea(vector<int>& heights)
	{
		int n = heights.size();
		vector<int>l(n, -1), r(n, n);
		vector<int>st;
		for (int i = 0; i < heights.size(); i++)
		{
			while (!st.empty() && heights[st.back()] >= heights[i])
				st.pop_back();
			l[i] = st.empty() ? -1 : st.back();
			st.push_back(i);
		}
		st.clear();
		for (int i = heights.size() - 1; i >= 0; i--)
		{
			while (!st.empty() && heights[st.back()] >= heights[i])
				st.pop_back();
			r[i] = st.empty() ? n : st.back();
			st.push_back(i);
		}
		int ret = 0;
		for (int i = 0; i < heights.size(); i++)
		{
			ret = max(ret, heights[i] * (r[i] - l[i] - 1));
		}
		return ret;
	}
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(n)$ 