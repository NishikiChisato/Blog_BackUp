---
title: LC 931.下降路径最小和
tags: [动态规划, 路径问题]
categories: Algorithm Solution
---

#### [931. 下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum/)

给你一个 `n x n` 的 **方形** 整数数组 `matrix` ，请你找出并返回通过 `matrix` 的**下降路径** 的 **最小和** 。

**下降路径** 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 `(row, col)` 的下一个元素应当是 `(row + 1, col - 1)`、`(row + 1, col)` 或者 `(row + 1, col + 1)` 。



#### DP 数组

还是按照原先的思路，我们定义 `dp[i][j]` 为到达点 $(i,\ j)$ 的最短距离

我们直接来看对于状态转移方程的讨论

容易看出，对于点 $(i,\ j)$ 

只要 `j != n - 1` ，那么都可以从右上和上方转移过来

只要 `j != 0` ，那么都可以从左上和上方转移过来

基于此我们便可以写出状态转移方程，然后取三个数的最小值赋给 `dp[i][j]`即可

```cpp
class Solution {
public:
	int minFallingPathSum(vector<vector<int>>& matrix)
	{
		int n = matrix.size(), m = matrix[0].size();
		vector<vector<int>>dp(n, vector<int>(m, 0));
		for (int j = 0; j < m; j++)
			dp[0][j] = matrix[0][j];
		for (int i = 1; i < n; i++)
		{
			for (int j = 0; j < m; j++)
			{
				dp[i][j] = dp[i - 1][j] + matrix[i][j];
				if (j > 0)
					dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + matrix[i][j]);
				if (j < m - 1)
					dp[i][j] = min(dp[i][j], dp[i - 1][j + 1] + matrix[i][j]);
			}
		}
		int ret = INT32_MAX;
		for (int n : dp[n - 1])
			ret = min(ret, n);
		return ret;
	}
};
```

时间复杂度：$O(n^2)$ 

空间复杂度：$O(n^2)$ 

这里有一个细节，如果状态转移方程我这么写：

```cpp
dp[i][j] = dp[i - 1][j];
if (j > 0)
    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1]) + matrix[i][j];
if (j < m - 1)
    dp[i][j] = min(dp[i][j], dp[i - 1][j + 1]) + matrix[i][j];
```

看上去好像每错，事实上我第一次就是这么写的，我自己看了半天还没发现，无语。。。

事实上，这么写会导致 `matrix[i][j]` 被加了两次，外面只需要它加一次就行，这么写是错的