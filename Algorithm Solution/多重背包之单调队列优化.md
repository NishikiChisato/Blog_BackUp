---
title: 多重背包之单调队列优化
tags: [背包, 动态规划]
categories: Algorithm Solution
---

### 问题描述

有 $N$ 种物品和一个容量是 $V$ 的背包，每种物品数量有限

第 $i$ 件物品的体积为 $v[i]$ ，价值为 $w[i]$ ，数量为 $s[i]$ 

求解将哪些物品装入背包使得总价值最大

​	 

### 前言

前天，我晚上坐在图书馆像往常一样打开了三叶姐姐背包合集当中的多重背包，毕竟学到这个了嘛

第一篇，就是最朴素的解法，因为有完全背包的处理经验，所以我觉得很简单，大概看了一下问题描述就去敲代码了，最后的代码在思路上基本一致，我也就过了。毕竟简单，差不多花了十分钟左右吧

然后第二篇，二进制优化。说实话我初步看的时候卡了一下，她举了个例子，说是 10 里面的数可以拆成 1 2 4 3 这四个数的不同排列组合，看到这个地方我其实有点懵，但我还是继续去看代码

关于代码的循环部分为什么要不断乘 2 ，这个问题一开始确实是卡到我了。但后来我从时间复杂度的角度想到，这个算法是将时间复杂度降到 $O(n^2logn)$ ，也就是用 $logn$ 个数去替代掉原先的 $n$ 个数，而 $logn$ 就是 2 的次幂，因此不断乘 2 的原因也就出来了

至于那个例子当中的 3 ，这属于是 10 不断减去 2 的次幂得到的余数。至此，代码思路我已经完全理解了，后面就是简单的 0-1 背包。到这里为止，我差不多花了三四十分钟吧，还算是比较简单

然后，那天晚上我以为，我能把最终 $O(n^2)$ 的优化看完（事实证明我还是太天真了

这个算法，我对它的印象就是？？？？？？？？？？？？？？

什么玩意儿？？？？？？？？

取余？？？？单调队列？？？？？？

然后我想着，去看看代码，说不定就会了呢，毕竟二进制优化我就是看代码看明白的

然后，我看到那个那个循环变量初值的设置，我？？？？？？？？？

往下看，那个循环的判断，我。。。。我怕不是个智障（别骂了别骂了，qwq

那天晚上就是在死磕那道题，在必应上面各种找，最后也是什么都没有看明白

转机发生在昨天

我尝试去做了一下单调队列的经典问题之后，大概理解了这玩意的思想

我去 Acwing 上面找了两个题解，对着看，然后自己在那里想，最后拿着纸笔一步一步从数学的角度来推，最后才大概理解了

不得不说，昨天那三个多小时的专注，我只想说，好爽啊！一回神，三个小时没了（下次还敢（（

然后今天凌晨的时候把代码敲了一下，有一些细节方面的问题，但我的理解是没错的

今天晚上把整个思路整理了一下，写出来这篇博客

姑且记录一下这三天的心路历程，太TM艰辛了（唉，人都想麻了，终于会了

我不敢保证我的思路就一定没有错误，但我觉得它是逻辑自洽的（确信，哈哈哈

嘛，想说的就这些

​	 

### 单调队列优化

关于这个问题的朴素解法和二进制优化，我们在前面已经说过了，这两个没有什么思维难度，我们主要看这个

我们 $dp$ 数组的定义是：考虑前 $i$ 个物品，在背包容量不超过 $j$ 的情况下的最大价值为 $f(i,j)$ （我们这里为了便于讨论，用 $f$ 替代 $dp$ ）

原先朴素解法的时间复杂度为 $O(n^3)$ ，在 $f$ 定义不变的情况下，由于存在 $O(n^2)$ 个状态，因此时间复杂度最小都是 $O(n^2)$ 

这里多出来的 $O(n)$ 是因为需要对每个物品遍历 $s[i]$ 次，也就是总状态为 $O(n^3)$ 

二进制优化的点在于，减少对每个物品的遍历次数，将遍历 $s[i]$ 次降为遍历 $log\ s[i]$ 次，这里是基于对物品个数的优化

我们现在考虑对状态进行分组

一般地，设第 $i$ 件物品的体积为 $vi$ ，价值为 $wi$ ，个数为 $si$ 

$f(i,j)$ 的状态只能由 $f(i,j-vi) ,\ f(i,j-2*vi) ,\ f(i,j-3*vi),\ \cdots,\ f(i,j-si*vi)$

观察上式，不难发现： $j-si*vi$ 会得到一个余数，**而对于同一个余数内的所有状态而言，它们只能由前面跟该状态余数相同的状态转移过来**

所以，我们便可以通过「同余」这一点来进行分组，我们只需要单独处理组内的状态，再将所有组合起来就得到了所有状态

更一般地，我们有：
$$
f(i,j)=max(f(i,j),\ f(i,j-v)+w,\ f(i, j-2v)+2w,\ \cdots,\ f(i, j-s*v)+s*w)
$$
考虑与完全背包一样的处理方法，将 $j$ 向后减一位，有：
$$
f(i,j-v)=max(f(i,j-v),\ f(i,j-2v)+w,\ f(i,j-3v)+2w,\ \cdots,\ f(i,j-(s+1)*v)+w)
$$
当我们将这个过程重复下去，有：
$$
\left\{\begin{array}{l}
f(i,j)=max(f(i,j),\ f(i,j-v)+w,\ f(i, j-2v)+2w,\ \cdots,\ f(i, j-s*v)+s*w)\\
f(i,j-v)=max(f(i,j-v),\ f(i,j-2v)+w,\ f(i,j-3v)+2w,\ \cdots,\ f(i,j-(s+1)*v)+w)\\
f(i,j-2v)=max(f(i,j-2v),\ f(i,j-3v)+w,\ f(i,j-4v)+2w),\ \cdots,\ f(i,j-(s+2)*v)+w)\\
\cdots \\
f(i,r+s*v)=max({\color{violet}f(i,r+s*v),\ f(i,r+(s-1)*v)+w,\ \cdots,\ f(i,r)+s*w})\\
f(i,r+2v)=max(f(i,r+2v),\ f(i,r+v)+w,\ f(i,r)+2w)\\
f(i,r+v)=max(f(i,r+v),\ f(i,r)+w)\\
f(i,r)=f(i,r)
\end{array}\right.
$$
其中 $r=j \bmod v$ 

如此这般，我们便实现了对 $j$ 的余数进行分组

 观察上面这个过程，会有如下两个结论：

* 自顶向下看，长度会先不变后减小
  * 在长度不变时，**改变的是该长度窗口内的状态**

* 自底向上看，长度会先增大，在达到 $(s+1)$ 时不再改变
  * 由于该种物品只有 $s$ 个，因此窗口内可以达到的最大状态为 $(s+1)$ （$v$ 前面的系数从 $0$ 增长到 $s$ ，因此为 $(s+1)$）

​	 

到此为止，我们将所有的状态按照**同余**进行了分组，并且对于某个状态 $j$ ，其值只能由同组当中的其他状态转移而来

并且，这里的「其他状态」是有**数量限制**的，这便构成了一个滑动窗口

对于状态 $f(i,j)$ 的值，我们需要找出该滑动窗口当中的**最大值**来进行更新

在滑动窗口中找最大值，这就是经典的单调队列问题了

​	 

具体操作如下：

我们将二维 $dp[i][j]$ 数组压缩成一维 $dp[j]$，其**定义不变**

原本进行状态压缩的时候，**循环是不需要变动的**，这也就导致了未对 `dp` 数组赋值之前，其值表示前一行的数值

但这里，我们仅仅是外层循环不变（因为我们还是需要对 $N$ 种物品进行遍历），第二层循环需要通过**枚举余数来进行分组**

由于第二层循环不再是**枚举背包剩余容量**，因此我们需要一个**辅助数值来记录上一次 `dp` 数组当中的数值**

第二层枚举余数的时候，每次自增 1 ，每枚举一次，就相当于是一个组

对于每个组，我们都需要一个单调队列，并且组的个数一定是小于 `v[i]` 的（因为这是对除以 `v[i]` 得到的余数进行枚举，最大值只能是 `v[i]-1`）

在最内层，我们需要对同一组当中的所有状态进行枚举（添加到单调队列当中），因此这一层每次自增的大小为 `v[i]` 

可以看到，虽然循环有三层，但里面两层都是在考虑物品恒定的情况下枚举所有的状态，这里一共的时间复杂度是 $O(n)$ （这里相当于原本二维 `dp` 函数当中枚举某一行）

所有总共的时间复杂度为 $O(n^2)$ 

​	 

代码如下：

```cpp
int back(int N, int V, vector<int>& s, vector<int>& v, vector<int>& w)
{
    vector<int>dp(V + 1, 0);
    vector<int>pre;//辅助队列，对上一次dp数组的值进行保留
    vector<int>q;//当前队列，对窗口内的状态进行处理
    for (int i = 0; i < N; i++)
    {
        pre = dp;//将dp数组当中所有状态的值赋值给pre

        for (int j = 0; j < v[i]; j++)//枚举余数
        {
            int tail = -1, head = 0;//对于每个组，都需要一个单调队列
            for (int k = j; k <= V; k += v[i])//枚举状态，每次自增一个v
            {
                //删去不在窗口内的元素，单调队列删除元素是在队头
                while (head <= tail && q[head] < k - s[i] * v[i])
                    head++;
                //保证单调队列的单调性，从队尾删除
                while (head <= tail && pre[q[tail]] - (q[tail] - j) / v[i] * w[i] <= q[k] - (k - j) / v[i] * w[i])
                    tail--;
                //给dp数组进行赋值，用前面已经保存的dp数组，即pre数组
                if (head <= tail)
                    dp[k] = max(dp[k], pre[q[head]] + (k - q[head]) / v[i] * w[i]);
                //将状态插入队列
                q[++tail] = k;
            }
        }
    }
    return dp[V];
}
```

时间复杂度：$O(n^2)$ 

空间复杂度：$O(n)$ 

​	 

这里我们详细说明一下最内层当中四行代码的意义，其余部分在上面均有解释，在此不过多说明

* `while (head <= tail && q[head] < k - s[i] * v[i])`
  * 由于我们是一个滑动窗口，并且该窗口大小恒定，那么必然会有尾端的状态离开窗口
  * 回顾上面的推导，窗口内的状态是从 $f(i,j)$ 到 $f(i,j-s*v)$ ，因此当队列头部的状态下标小于 $k - s * v$ 的话（**这里的 $k$ 是该组当中的所有状态，即 $k=t*v+j$ ，其中 $0\le t\le s$**），需要将该元素出队
  * 由于这是个单调队列，需要维护队列内部元素的单调性，因此出队的元素只能是最大值并且从队头出队

* `while (head <= tail && pre[q[tail]] - (q[tail] - j) / v[i] * w[i] <= q[k] - (k - j) / v[i] * w[i])`
  
  * 这一条是为了保证队列的单调性，当出现一个元素比队尾元素大时，需要将小于该元素的队中元素从队尾排出
  
  * `pre[q[tail]]` 表示在 `dp` 数组当中处于「队尾」元素的状态的值，那么为什么要减去一个值呢？
  
  * 观察上面的式子，每一条式子当中的对应项总是差 $t*w$ 。反过来说，我们从 $f(i,j)$ 转移到 $f(i,j+v)$ 与 $f(i,j+2v)$ 所需要加上的 $w$ 是不一样的，而这里我们又是从前往后推，因此需要减去对应的 $w$ 
  
  * 这里的 $t*w$ 很容易求出，由于 $q[tail],\ k$ 均是类似于 $t*v+j$ 的形式，因此拿它们减去 $j$ 再除以 $v$ 乘上 $w$ 就是对应的 $t*w$ 的值
*  `dp[k] = max(dp[k], pre[q[head]] + (k - q[head]) / v[i] * w[i])`
  
  * 这里我们是对 `dp[k]` 这个状态进行赋值，其值主要来自于队列的队头
  
  * 由于我们是从队头来推 `dp[k]` ，因此我们需要加上一个 $t*w$ 
  
  * 我们知道，$k$ 所代表的状态一定在队头所表示的状态的后面，因此 $k$ 一定大于队头状态 $q[head]$ ，后续处理跟上面一致
* `q[++tail] = k` 
  * 这里我们是将各个不同的**「状态」**入队。这里的「状态」，指的是**背包不同的体积**
  
  * 由于我们的队列初始状态是 `tail = -1, head = 0` ，因此入队是将 `tail++` ，队头出队是 `head++` ，队尾出队是 `tail--` ，并且队列不为空的条件是 `head <= tail` ，初始时将二者设置相反也有利于判空

