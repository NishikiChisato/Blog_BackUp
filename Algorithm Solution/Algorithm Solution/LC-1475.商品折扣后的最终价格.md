---
title: LC 1475.商品折扣后的最终价格
tags: [模拟, 单调栈]
categories: Algorithm Solution
---

#### [1475. 商品折扣后的最终价格](https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/)

给你一个数组 `prices` ，其中 `prices[i]` 是商店里第 `i` 件商品的价格。

商店里正在进行促销活动，如果你要买第 `i` 件商品，那么你可以得到与 `prices[j]` 相等的折扣，其中 `j` 是满足 `j > i` 且 `prices[j] <= prices[i]` 的 **最小下标** ，如果没有满足条件的 `j` ，你将没有任何折扣。

请你返回一个数组，数组中第 `i` 个元素是折扣后你购买商品 `i` 最终需要支付的价格。


```
输入：prices = [8,4,6,2,3]
输出：[4,2,4,2,3]
解释：
商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。
商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。
商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。
商品 3 和 4 都没有折扣。
```



#### 模拟

我们看到，`prices[i]` 的范围只有 $10^3$ ，因此可以直接模拟。

```cpp
class Solution {
public:
    vector<int> finalPrices(vector<int>& prices) 
    {
        vector<int>ret(prices.size(), 0);
        for(int i = 0; i < prices.size(); i++)
        {
            ret[i] = prices[i];
            for(int j = i + 1; j < prices.size(); j++)
            {
                if(prices[j] <= prices[i])
                {
                    ret[i] = prices[i] - prices[j];
                    break;
                }
            }
        }
        return ret;
    }
};
```

时间复杂度：$O(n^2)$，最坏的情况需要将这个数组遍历两遍 

空间复杂度：$O(1)$



#### 单调栈

我们先说明一下何为「单调栈」。

顾名思义，单调栈中的元素具有单调性的特征，或单调递增或单调递减。

在插入元素的时候，我们仍需要让这个栈保持上述特性，如此这般，我们便得到了一个单调栈。

关于单调栈的插入，我们有以下操作：

```cpp
while(!stack.empty() && stack.top() < val)
    stack.pop();
stack.push(val);
```

我们来分析一下这个题为什么可以用单调栈？

具体地，我们从前往后遍历 `nums` 数组，将「待打折」商品的**下标**存放在某个容器当中，我们考察 `nums[i]` 元素

* 若 `nums[i]` 大于该容器中任意一个元素，说明我们不能用 `nums[i]` 对容器内的商品进行打折，因此需要将 `nums[i]` 添加到该容器中
  * 更进一步，我们每次都会将一个「大于该容器中任意一个元素」的元素添加到该容器中，因此我们很容易可以得出此容器中的元素具有**单调递增**的特性
* 若 `nums[i]` 小于该容器中的最后一个元素（上一次添加的元素），那么我们便可以将尾部商品从容器中取出（因为该商品可以得到折扣）。由于该动作需要**重复多次**，因此我们只能使用 `while` 而不能用 `if` 。并且该动作需要在**添加元素之前执行**。

根据上述讨论，该容器的元素只能从尾部进，从尾部出，因此只能是栈。到此为止，我们便构造出了一个单调栈的理论框架，下面就是代码的部分了。

```cpp
class Solution {
public:
	vector<int> finalPrices(vector<int>& prices)
	{
		vector<int>ret(prices.size(), 0);
		stack<int>st;//存储元素索引
		for (int i = 0; i < prices.size(); i++)
		{
			while (!st.empty() && prices[st.top()] >= prices[i])
			{
				int index = st.top();
				ret[index] = prices[index] - prices[i];
                st.pop();//记得把元素弹出来
			}
			st.push(i);
			ret[i] = prices[i];
		}
        return ret;
	}
};
```

时间复杂度：$O(n)$

空间复杂度：$O(n)$ ，最坏需要 $n$ 个大小的栈来存储



补充：为什么是存储数组元素索引而不是直接存储数组元素？

实际上，这个问题很容易就可以得出答案，如果我们存储的是数组元素，那么该元素在出栈时就无法确定到底是 `nums` 中哪个元素得到折扣，如果存储索引就没有这个问题。
