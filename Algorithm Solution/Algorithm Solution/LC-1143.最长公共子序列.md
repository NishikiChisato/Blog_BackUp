---
title: LC 1143.最长公共子序列 
tags: [LCS, 动态规划, 模板题目]
categories: Algorithm Solution
---

#### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```



#### dp 函数

如果是对两个字符串直接整个求 `LCS` 的话，这个过程会根本没有思路

因此我们需要将这个问题细化一下，我们去求**指定区间的 `LCS` **，想到这里，`dp` 函数的定义就已经呼之欲出了：

`int dp(string& s1, int i, string& s2, int j)` 的定义为区间 `s1[i, s1.length]` 和区间 `s2[j, s2.length]` 的最长公共子序列

这个地方从后面开始遍历跟从前面开始遍历是一样的，我们用后往前的

此时，起始遍历点为 `dp(s1.length - 1, s2.length - 1)`

显然，当两个字符串中有一个遍历完了，我们就需要结束递归，因此

```cpp
if(i == -1 || j == -1)
    return 0;
```

现在有了定义之后，我们发现求一个区间的最长公共子序列还是很困难，我们需要继续将问题细化

最长公共子序列，说到底也是由一个一个字符所组成的，也就是说只要 `s1[i] == s2[j]` ，那么当前字符就一定在 `LCS` 内，因此我们需要返回 `return 1 + dp(s1, i - 1, s2, j - 1)`

想到这里其实就已经结束了，剩下的我们需要考虑 `s1[i] != s2[j]` 的情况

我们还是从字符是否在 `LCS` 内来开始讨论，对于这种两个字符不相等的情况，不外乎三种可能：

* `s1` 不在，`s2` 在
* `s1` 在，`s2` 不在
* `s1` 与 `s2` 均不在

由于我们需要求的是最长公共子序列，因此这三种情况我们需要求一个最大值，即：`max(dp(i-1, j), dp(i, j-1), dp(i-1, j-1))` ，这三个与上面的三个依次对应

因此我们最终的代码如下：

```cpp
	int dp(string& s1, int i, string& s2, int j)//s1[i,...],s2[j,...]当中的最长公共子序列
	{
		if (i == -1 || j == -1)
			return 0;
		if (s1[i] == s2[j])
			return 1 + dp(s1, i - 1, s2, j - 1);
		else
			return max(dp(s1, i - 1, s2, j - 1), max(dp(s1, i - 1, s2, j), dp(s1, i, s2, j - 1)));
	}

	int longestCommonSubsequence(string text1, string text2)
	{
		return dp(text1, text1.length() - 1, text2, text2.length() - 1);
	}
```

这个代码在 LC 上面会因为超时而过不了，我们需要加一个备忘录来进行去重



#### dp 函数 + 备忘录

```cpp
class Solution {
public:
	vector<vector<int>>memo;

	int dp(string& s1, int i, string& s2, int j)//s1[i,...],s2[j,...]当中的最长公共子序列
	{
		if (i == -1 || j == -1)
			return 0;
		if (memo[i][j] != -1)
			return memo[i][j];
		if (s1[i] == s2[j])
			memo[i][j] = 1 + dp(s1, i - 1, s2, j - 1);
		else
			memo[i][j] =  max(dp(s1, i - 1, s2, j - 1), max(dp(s1, i - 1, s2, j), dp(s1, i, s2, j - 1)));
		return memo[i][j];
	}

	int longestCommonSubsequence(string text1, string text2)
	{
		int n = text1.length(), m = text2.length();
		memo.assign(n, vector<int>(m, -1));
		return dp(text1, text1.length() - 1, text2, text2.length() - 1);
	}
};
```

时间复杂度：$O(m * n)$ 

空间复杂度：$O(m * n)$ 



#### dp 数组

用 `dp` 数组来解，同样是从前往后与从后往前都一样，我们采取从前往后

由前面的分析我们可以确定，我们需要从 `dp[i - 1][j]` 或者是 `dp[i][j - 1]` 来推出 `dp[i][j]` 

如果我们采取字符串索引与数组索引一一对应的形式，那么势必会导致字符串的索引越界，因此我们需要让字符串进行一下偏移，让**字符串的 0 索引对应数组的 1 索引**，之后我们再在这个基础上面考虑初始情况

**在有索引偏移的情况下，在 `dp` 数组当中的的初始情况就是去对 `dp[i][0]` 与 `dp[0][j]` 进行赋初值**

由于我们将字符串整体向右偏移了一位，因此数组的 0 索引在字符串这边没有任何的意义，因此也不需要对数组进行初始化

在对字符串进行访问时，只需要记住其索引是 `i - 1` 或者 `j - 1` ，剩下的就没有问题了

```cpp
class Solution {
public:
	int longestCommonSubsequence(string text1, string text2)
	{
		int n = text1.length(), m = text2.length();
		vector<vector<int>>dp(n + 1, vector<int>(m + 1, 0));
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= m; j++)
			{
				if (text1[i - 1] == text2[j - 1])
					dp[i][j] = 1 + dp[i - 1][j - 1];
				else
					dp[i][j] = max(dp[i - 1][j - 1], max(dp[i - 1][j], dp[i][j - 1]));
			}
		}
		return dp[n][m];
	}
};
```

时间复杂度：$O(n * m)$ 

空间复杂度：$O(n * m)$ 



#### 总结

这是一道涉及**两个**字符串/数组的场景，我们采用二维的 `dp` 数组来解决这个问题，其相关定义为：

在数组 `arr1` 和数组 `arr2` 中，子数组 `arr1[0..i]` 和子数组 `arr2[0..j]` 中，所求子序列长度为 `dp[i][j]` 

当涉及具体迭代时，采用：

```cpp
for(int i : n)
    for(int j : m)
        if(arr1[i] == arr2[j])
            dp[i][j] = 特殊情况
        else
            dp[i][j] = 最值情况
```



#### 最后

感觉之前做题完全没有一个清晰的思路，拿到一道新题完全下不了手的那种

感觉这种情况就跟这道题最开始是一样的，对整个问题进行分析是无从下手的，应该去将问题**细化**，直到最后可以分析出来为止

所以，我想将这道题作为我细化题目的一个最小单位，其他的问题可以由这道题延申拓展出来，或者说我做的其他题可以细化到这道题上面，这就是我的目的

嘛，这种「最小单位」肯定是需要不断做题积累总结的，只能说是慢慢来吧

