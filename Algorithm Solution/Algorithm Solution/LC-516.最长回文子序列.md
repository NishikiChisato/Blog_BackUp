---
title: LC 516.最长回文子序列
tags: [动态规划, 模板题目]
categories: Algorithm Solution
---

#### [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

```
输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
```



#### DP 数组

关于前面[LC 1143.最长公共子序列](https://nishikichisato.github.io/2022/09/04/Algorithm Solution/LC-1143.最长公共子序列/)的问题中，我们是按照 `s1[0..i]` 这样分析的

也就是说，我们其实是**默认检索区间的左端点的不动性**，这在遍历子序列是不会有什么问题的。因为我们只是对一个区间进行检索，看这里面是否存在 `LCS` 而已

但这道题不能这么做，或者说这么做问题会很复杂

我们同样是采取细化问题的思路，那么我们如何让目前已有的回文字符串更长一点？

是不是只需要检索这个已有子串**向外延申出去的第一个字符是否相等**就行，从这里就可以看出来，我们不能采用区间左端点不动的方式

于是乎，我们给出以下 `dp` 数组的定义：

`dp[i][j]` 的定义为：区间 `s[i..j]` 当中最长的回文子序列

然后，我们来看看初始情况

这里我们默认 `i <= j` ，也就是说 `i > j` 的部分（矩阵左下角）全部为 0

当 `i == j` 时，也就是此时只有一个字符，此时回文串长度为 1 ，因此此矩阵的对角线部分全部为 1

上面是初始情况的分析

刚刚我们说到，我们需要**检索已检索区间向外延申的第一个字符是否相同**，因此在这在情况下，`dp[i][j]` 由`dp[i + 1][j - 1]` 推出，即：

```cpp
if(s[i] == s[j])
    dp[i][j] = dp[i + 1][j - 1] + 2;//长度加 2
```

接着我们看这两个字符不相同的情况

由于我们的 `dp` 函数的定义是区间 `s[i..j]` 的最长回文子序列，因此我们只需要将左右两个字符分别添加到已检索区间内，然后再取二者的较大值即可，即：

```cpp
dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
```

需要注意的是，我们只是**扩大了检索区间**，并不是扩大了最长子序列的长度

到此为止，基本思路已经分析完毕，但还没有结束

我们目前需要对矩阵区域的右上角进行遍历，然后我们的 `dp[i][j]` 是由 `dp[i - 1][j - 1]` 、`dp[i + 1][j]` 、`dp[i][j - 1]` 这三个点推出，也就是说，我们需要从矩阵的最下面开始遍历，然后再逐渐往上

外层循环 `i` 的开始点为 `n - 1` ，内层循环的开始点为 `i + 1` （这里画图很容易理解），之后开始循环即可

完整代码如下：

```cpp
class Solution {
public:
	int longestPalindromeSubseq(string s)
	{
		int n = s.length();
		vector<vector<int>>dp(n, vector<int>(n, 0));
		for (int i = 0, j = 0; i < n && j < n; i++, j++)
			dp[i][j] = 1;
		for (int i = n - 1; i >= 0; i--)
		{
			for (int j = i + 1; j < n; j++)
			{
				if (s[i] == s[j])
					dp[i][j] = 2 + dp[i + 1][j - 1];
				else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
			}
		}
		return dp[0][n - 1];
	}
};
```

时间复杂度：$O(n^2)$，有 $n^2$ 个状态 

空间复杂度：$O(n^2)$ 



#### 总结

前文[LC 1143.最长公共子序列](https://nishikichisato.github.io/2022/09/04/Algorithm Solution/LC-1143.最长公共子序列/)中，我们见到了二维 `dp` 数组的一种定义

这里我们见到了二维 `dp` 数组的另一种定义：

在子序列 `s[i..j]` 中， 所要求的子序列长度为 `dp[i][j]` 

至于遍历方式，这一点根据题目的意思来