---
title: LC 1289.下降路径最小和 II
tags: [动态规划, 路径问题]
categories: Algorithm Solution
---

#### [1289. 下降路径最小和  II](https://leetcode.cn/problems/minimum-falling-path-sum-ii/)

给你一个 `n x n` 整数矩阵 `arr` ，请你返回 **非零偏移下降路径** 数字和的最小值。

**非零偏移下降路径** 定义为：从 `arr` 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。

```
输入：arr = [[1,2,3],[4,5,6],[7,8,9]]
输出：13
解释：
所有非零偏移下降路径包括：
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。
```



#### DP 数组（朴素解法）

对于 `dp[i][j]` 而言，其值由上一行当中除掉 `dp[i - 1][j]` 之外的所有值的最小值

这种解法很简单，时间复杂度是 $O(n^3)$ ，这里的数量级是 $10^2$ ，一共是 $10^6$ ，小于 $10^7$ ，可以过

```cpp
class Solution {
public:
	int minFallingPathSum(vector<vector<int>>& grid)
	{
		int n = grid.size();
		vector<vector<int>>dp(n, vector<int>(n, 0));
		for (int j = 0; j < n; j++)
			dp[0][j] = grid[0][j];
		for (int i = 1; i < n; i++)
		{
			for (int j = 0; j < n; j++)
			{
				dp[i][j] = INT32_MAX;
				for (int k = 0; k < n; k++)
				{
					if (k == j)
						continue;
					dp[i][j] = min(dp[i][j], dp[i - 1][k]);
				}
				dp[i][j] += grid[i][j];
			}
		}
		int ret = INT32_MAX;
		for (int m : dp[n - 1])
			ret = min(ret, m);
		return ret;
	}
};
```

时间复杂度：$O(n^3)$

空间复杂度：$O(n^2)$



#### DP 数组（时间优化）

对于这道题，`dp` 数组有 $n^2$ 个状态，这个部分是不可能得到优化的，唯一可以入手的地方是**不对前一行进行遍历**

我们原本是想， `dp[i][j]` 的值是上一行当中除掉 `dp[i][j - 1]` 的最小值，这么想的话必然需要进行多一次循环，因为我需要全部遍历一遍上一行的所有值

但是，我们从最小值的角度来想，不管怎么样，`dp[i][j]` 的值一定是上一行的最小值，只不过这个最小值可能会在 `dp[i - 1][j]` ，也可能不会在

对于不在的情况，我们直接将 `i - 1` 行的最小值赋给 `dp[i][j]` 即可

对于在的情况，我们将 `i - 1` 行的**次小值**赋值给 `dp[i][j]` 即可

这样，我们只需要记录上一行的两个值，就可以推出 `dp[i][j]` 

我们定义两个下标，`fir` 用于记录最小值，`sec` 用于记录次小值，初始状态先让二者为 -1

然后我们先对二者做一个判断，只要二者为 -1 就对它们赋值

之后就是常规的递推，`fir` 对 `sec` 赋值，`j` 对 `fir` 赋值

全部代码如下：

```cpp
class Solution {
public:
	int minFallingPathSum(vector<vector<int>>& grid)
	{
		int n = grid.size();
		vector<vector<int>>dp(n, vector<int>(n, 0));
		int fir = -1, sec = -1;//fir记录最小值下标, sec记录次小值下标
		for (int j = 0; j < n; j++)
		{
			int val = grid[0][j];
			dp[0][j] = val;

			if (val < (fir == -1 ? INT32_MAX : dp[0][fir]))//这么写可以保证两个数都会被赋值
			{
				sec = fir;
				fir = j;
			}
			else if (val < (sec == -1 ? INT32_MAX : dp[0][sec]))
				sec = j;

		}

		for (int i = 1; i < n; i++)
		{
			int tfir = -1, tsec = -1;
			for (int j = 0; j < n; j++)
			{
				int val = grid[i][j];
				//我们已经预先求出了上一行的最小值和次小值，这里应该先赋值
				if (j != fir)
					dp[i][j] = dp[i - 1][fir] + val;
				else dp[i][j] = dp[i - 1][sec] + val;

				//下面对dp[i]行求最小值和次小值
				if (dp[i][j] < (tfir == -1 ? INT32_MAX : dp[i][tfir]))
				{
					tsec = tfir;
					tfir = j;
				}
				else if (dp[i][j] < (tsec == -1 ? INT32_MAX : dp[i][tsec]))
					tsec = j;
			}
			fir = tfir;
			sec = tsec;
		}
		int ret = INT32_MAX;
		for (int m : dp[n - 1])
			ret = min(ret, m);
		return ret;
	}
};
```

时间复杂度：$O(n^2)$ 

空间复杂度：$O(n^2)$ 