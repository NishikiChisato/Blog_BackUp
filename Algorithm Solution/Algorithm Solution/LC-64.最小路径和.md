---
title: LC 64.最小路径和
tags: [路径问题, 动态规划]
categories: Algorithm Solution
---

#### [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```



#### DP

这题目跟前面的 [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/) 基本不差吧，思路是一样的

我们定义 $dp[i][j]$ 表示机器人到达点 $(i,j)$ 所需的**最小**路径和

机器人站在某一点处不外乎有三种选择：

* 该位置只能向下走，则 $dp[i][j] = dp[i - 1][j] + grid[i][j]$ ，我们求的是路径和，一定要加上 $grid$ 的值
* 该位置只能向右走，则 $dp[i][j] = dp[i][j - 1] + grid[i][j]$ 
* 该位置即能向下也能向右，则 $dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]$ 

这三点明确之后，代码就很简单了

```cpp
class Solution {
public:
	int minPathSum(vector<vector<int>>& grid)
	{
		int m = grid.size(), n = grid[0].size();
		vector<vector<int>>dp(m, vector<int>(n, 0));
		dp[0][0] = grid[0][0];
		for (int i = 0; i < m; i++)
		{
			for (int j = 0; j < n; j++)
			{
				if (i > 0 && j > 0)
					dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
				else if (i > 0)
					dp[i][j] = dp[i - 1][j] + grid[i][j];
				else if (j > 0)
					dp[i][j] = dp[i][j - 1] + grid[i][j];
			}
		}
		return dp[m - 1][n - 1];
	}
};
```

时间复杂度：$O(m * n)$ 

空间复杂度：$O(m * n)$ 

