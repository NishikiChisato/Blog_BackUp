---
title: LC 208.实现 Trie (前缀树)
tags: [Trie, 数据结构设计]
categories: Algorithm Solution
---

#### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。



```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```



#### 多叉树实现

$Trie$ 树，也称为字典树或前缀树，是一种用于快速查询「某个字符串、字符前缀」是否存在的数据结构

既然是树，我们先来看看它的节点构成

```cpp
class Trie
{
private:
	bool isEnd;
	vector<Trie*>next;
}
```

可以看到，不同于典型树的结构——每个节点存储数值

Trie 树的**节点**存储的是一个 `bool` 值，表示该节点**是否为某个单词的结尾**

Trie 树的边表示的是**一个字符是否存在**，这一部分是采取数组来存储的

如果该字符存在，那么指针指向下一个节点，如果不存在，那么该指针为空

这个东西的实现，其实不难，难的是具体应用，我们直接给出代码

```cpp
class Trie {
private:
	bool isEnd;
	vector<Trie*>next;
public:
	Trie()
		:isEnd(false), next(26)
	{  }

	void insert(string word)
	{
		Trie* node = this;
		for (char c : word)
		{
			if (node->next[c - 'a'] == nullptr)
				node->next[c - 'a'] = new Trie();
			node = node->next[c - 'a'];
		}
		node->isEnd = true;
	}

	bool search(string word)
	{
		Trie* node = this;
		for (char c : word)
		{
			if (node->next[c - 'a'] == nullptr)
				return false;
			node = node->next[c - 'a'];
		}
		return node->isEnd;
	}

	bool startsWith(string prefix)
	{
		Trie* node = this;
		for (char c : prefix)
		{
			if (node->next[c - 'a'] == nullptr)
				return false;
			node = node->next[c - 'a'];
		}
		return true;
	}
};
```

时间复杂度：$O(len)$ ，$len$ 为字符串长度

空间复杂度：$O(n*len)$ ，$n$ 为节点个数，$len$ 为字符集大小

​	 

#### 二维数组实现

需要注意的是，这个代码在力扣上面无法通过！！！

我们可以用一种简单的方式来解决这个问题

* 我们用二维数组 `trie` 来存储各个节点
* 用 `index` 的自增来记录当前已有的节点数量
* 用 `count` 来记录当前节点作为「单词结尾」的次数

```cpp
class Trie 
{
private:
	int N = 1e5;
	vector<vector<int>>trie;//数组，用于存储各个节点
	vector<int>count;//记录某个节点被标记为「某个单词的终点」的次数
	int index;//记录目前使用的节点数
public:
	Trie() 
	{
		trie.assign(N, vector<int>(26, 0));
		count.assign(N, 0);
		int index = 0;
	}

	void insert(string word) 
	{
		int pos = 0;
		for (char c : word)
		{
			if (trie[pos][c - 'a'] == 0)
				trie[pos][c - 'a'] = ++index;
			pos = trie[pos][c - 'a'];
		}
		count[pos]++;
	}

	bool search(string word) 
	{
		int pos = 0;
		for (char c : word)
		{
			if (trie[pos][c - 'a'] == 0)
				return false;
			pos = trie[pos][c - 'a'];
		}
		return count[pos] != 0;
	}

	bool startsWith(string prefix) 
	{
		int pos = 0;
		for (char c : prefix)
		{
			if (trie[pos][c - 'a'] == 0)
				return false;
			pos = trie[pos][c - 'a'];
		}
		return true;
	}
};
```

​	 

#### 二维数组（时间优化）

显然，如果我们每定义一个 Trie 对象，都需要一个很大的二维数组的开销

我们可以将这个二维数组转为静态，在每次执行构造函数的时候对以往的二维数组进行一次清理，这样便可以减小开销

```cpp
class Trie 
{
private:
	static const int N = 100009;
	static vector<vector<int>>trie(N, vector<int>(26, 0));//数组，用于存储各个节点
	static vector<int>count(N, 0);//记录某个节点被标记为「某个单词的终点」的次数
	static int index = 0;//记录目前使用的节点数
public:
	Trie() 
	{
		for(int i = index; i >= 0; i--)
        {
            trie[i].assign(26, 0);
        }
        count.assign(N, 0);
        index = 0;
	}

	void insert(string word) 
	{
		int pos = 0;
		for (char c : word)
		{
			if (trie[pos][c - 'a'] == 0)
				trie[pos][c - 'a'] = ++index;
			pos = trie[pos][c - 'a'];
		}
		count[pos]++;
	}

	bool search(string word) 
	{
		int pos = 0;
		for (char c : word)
		{
			if (trie[pos][c - 'a'] == 0)
				return false;
			pos = trie[pos][c - 'a'];
		}
		return count[pos] != 0;
	}

	bool startsWith(string prefix) 
	{
		int pos = 0;
		for (char c : prefix)
		{
			if (trie[pos][c - 'a'] == 0)
				return false;
			pos = trie[pos][c - 'a'];
		}
		return true;
	}
};
```

