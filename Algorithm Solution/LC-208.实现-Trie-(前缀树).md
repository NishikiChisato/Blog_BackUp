---
title: LC 208.实现 Trie (前缀树)
tags: [Trie, 数据结构设计]
categories: Algorithm Solution
---

#### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。



```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```



#### Trie

$Trie$ 树，也称为字典树或前缀树，是一种用于快速查询「某个字符串、字符前缀」是否存在的数据结构

既然是树，我们先来看看它的节点构成

```cpp
class Trie
{
private:
	bool isEnd;
	vector<Trie*>next;
}
```

可以看到，不同于典型树的结构——每个节点存储数值

Trie 树的**节点**存储的是一个 `bool` 值，表示该节点**是否为某个单词的结尾**

Trie 树的边表示的是**一个字符是否存在**，这一部分是采取数组来存储的

如果该字符存在，那么指针指向下一个节点，如果不存在，那么该指针为空

这个东西的实现，其实不难，难的是具体应用，我们直接给出代码

```cpp
class Trie {
private:
	bool isEnd;
	vector<Trie*>next;
public:
	Trie()
		:isEnd(false), next(26)
	{  }

	void insert(string word)
	{
		Trie* node = this;
		for (char c : word)
		{
			if (node->next[c - 'a'] == nullptr)
				node->next[c - 'a'] = new Trie();
			node = node->next[c - 'a'];
		}
		node->isEnd = true;
	}

	bool search(string word)
	{
		Trie* node = this;
		for (char c : word)
		{
			if (node->next[c - 'a'] == nullptr)
				return false;
			node = node->next[c - 'a'];
		}
		return node->isEnd;
	}

	bool startsWith(string prefix)
	{
		Trie* node = this;
		for (char c : prefix)
		{
			if (node->next[c - 'a'] == nullptr)
				return false;
			node = node->next[c - 'a'];
		}
		return true;
	}
};
```

时间复杂度：$O(len)$ ，$len$ 为字符串长度

空间复杂度：$O(n*len)$ ，$n$ 为节点个数，$len$ 为字符集大小