---
title: LC 238.除自身以外数组的乘积
tags: [前缀和, 数组]
categories: Algorithm Solution
---

#### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请**不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。

 

**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

 

**提示：**

- `2 <= nums.length <= 105`
- `-30 <= nums[i] <= 30`
- **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内

 

**进阶：**你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组**不被视为**额外空间。）

​	 

#### 前缀和数组

我们可以构建一个数组 `premul` 用于保存**前 `i`** 个数的乘积，数组 `endmul` 用于保存后 `i` 个数的乘积

特别地，有 `premul[0] = 1, endmul[n] = 1` 

这个地方主要是有一个前缀和的思想，会了这个之后这种方法就很简单了

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int>premul(n + 1, 1), endmul(n + 1, 1);
        premul[1] = nums[0], endmul[n - 1] = nums[n - 1];
        for(int i = 1; i < n; i++)
            premul[i + 1] = premul[i] * nums[i];
        for(int i = n - 2; i >= 0; i--)
            endmul[i] = endmul[i + 1] * nums[i];
        vector<int>ans(n, 0);
        for(int i = 0; i < n; i++)
            ans[i] = premul[i] * endmul[i + 1];
        return ans;
    }
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(n)$ 

​	 

#### 空间优化

我们可以从前往后遍历一遍 `nums` 数组，将前缀乘值全部记录到 `ans` 中，对于 `ans[0]` 我们需要将其置为一

第二次遍历的时候，我们从后往前遍历，将 `nums` 的后缀乘值全部记录到 `ans` 中，最后返回即可

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int>ans(n, 0);
        for(int i = 1, t = 1; i <= n; i++)
        {
            ans[i - 1] = t;
            t *= nums[i - 1];
        }
        for(int i = n - 2, t = 1; i >= -1; i--)
        {
            ans[i + 1] *= t;
            t *= nums[i + 1];
        }
        return ans;
    }
};
```

时间复杂度：$O(n)$ 

空间复杂度：$O(1)$ 

